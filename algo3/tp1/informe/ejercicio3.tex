\begin{section}{Problema 3}
	\textit{Dada una lista de ingresos y otra de egresos que contienen los horarios de ingreso y egreso de cada uno de los programadores de una empresa respectivamente, determinar la mayor cantidad de programadores que estan simultáneamente dentro de la empresa.}
	\begin{subsection}{Explicación}
		Para cada instancia tenemos una lista que contiene para cada programador su horario de ingreso a la empresa y otra con su horario de egreso. Además, tenemos guardado en cada momento la cantidad máxima de programadores en simultáneo.

Dado que ambas listas se encuentran ordenadas, nuestro algoritmo las recorre decidiendo a cada momento si se produce un ingreso o un egreso, es decir, si el horario que sigue en la lista de ingresos es anterior a la de egresos implica que hubo un ingreso, en caso contrario un egreso.

Cuando una persona ingresa a la empresa se incrementa el contador de la cantidad de programadores en simultáneo en el horario actual. Así, cuando se produce un egreso se compara si la cantidad de programadores dentro de la empresa previo a dicho egreso es mayor a la máxima cantidad de programadores en simultáneo hasta el momento, de ser así, actualizamos el máximo.

Luego se descuenta el recientemente egresado del contador parcial de cantidad de programadores en simultaneo.

Este procedimiento se repite hasta haber visto todos los ingresos, lo que nos garantiza tener el máximo correspondiente, ya que a partir de ese momento sólo se producirían egresos.

		\begin{subsubsection}{Análisis de complejidad}
			Elegimos el modelo uniforme para analizar la complejidad de este algoritmo porque el tamaño de los elementos es acotado y por lo tanto todas las operaciones elementales son de costo constante.\Pa
			
			Sea $n$ la cantidad de programadores, $j$ el indice dentro de la lista de ingresos y $k$ el indice dentro de la lista de egresos.\\
			
			\begin{pseudo}
				\func{programadores\_en\_simultaneo}{$ingresos, egresos$}
				\tab $max,tmp,j,k \leftarrow 0$ \\
				\tab \WHILE($j< n$) & \tOde{n}  \\
				\tab \tab \IF($ingresos[j]\leq egresos[k]$) \\
				\tab \tab \tab $tmp \leftarrow tmp+1$ \\
				\tab \tab \tab $j \leftarrow j+1$ \\
				\tab \tab \ELSE \\
				\tab \tab \tab \IF($tmp>max$) \\
				\tab \tab \tab \tab $max \leftarrow tmp$ \\
				\tab \tab \tab $tmp \leftarrow tmp - 1$ \\
				\tab \tab \tab $k \leftarrow k+1$ \\
				\tab \IF($tmp>max$) \\
				\tab \tab $max \leftarrow tmp$ \\
				\tab \RET $max$
			\end{pseudo}

			Cada programador tiene un ingreso y un egreso, por lo tanto la lista de ingresos y la lista de egresos tienen longitud $n$.

El algoritmo en todos los casos recorre completamente la lista de ingresos, por lo que el peor caso es cuando el último ingreso y el último egreso corresponden al mismo programador, ya que para registrar éste último ingreso, tambien tuvo que recorrer toda la lista de egresos. Por este motivo, podemos inferir que a lo sumo se realizan $2n -1$ iteraciones. En cada una de estas tenemos un costo constante de operaciones, que no modifican la complejidad en el análisis asintótico. La complejidad algorítmica entonces, es \Ode{n}.\VSP

		\noindent\textbf{En función del tamaño de la entrada}\\

			Como los elementos de ambas listas son de tamaño acotado, el tamaño de la entada es proporcional a la longitud de las listas (n). Entonces la complejidad del algoritmo es \Ode{t}, donde $t$ es el tamaño de la entrada. El algoritmo es lineal.

		\end{subsubsection}

	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
	Guardamos los horarios de ingreso de todos los programadores (de la misma forma que estan en el archivo de entrada, es decir, en orden creciente) en un arreglo de $strings$ (los cuales representan un horario en formato ``HH:MM:SS'') de tamaño $n$, donde $n$ es la cantidad de programadores. Además guardamos otro arreglo del mismo tamaño con los horarios de egreso.
	
	A medida que vamos recorriendo los arreglos $ingresos$ y $egresos$ necesitamos decidir si el horario de ingreso del programador $j$ es anterior o posterior al horario de egreso del programador $i$, esto lo hacemos comparando los $strings$ por menor o igual (que el horario de ingreso del programador $j$ sea el mismo que el horario de egreso del programador $i$ significa que ambos estuvieron en simultáneo en la empresa jústamente en ese horario ya que se considera que un programador permanece dentro de la empresa desde su horario de ingreso hasta su horario de egreso, incluyendo ambos extremos). Si la comparación resulta verdadera significa que el programador $j$ ingresa a la empresa por lo que incrementamos el contador de programadores en simultáneo en ese horario. En caso contrario lo decrementamos ya que el programador $i$ egresa. Antes de decrementar dicho contador verificamos si la cantidad de programadores en simultáneo previo al egreso de $i$ es mayor a $max$ (máxima cantidad de programadores en simultáneo calculada hasta el momento) y de ser necesario actualizamos $max$.

	Una vez que terminamos de recorrer la lista de ingresos, actualizamos $max$ ya que desde el último egreso visto se pueden haber producido nuevos ingresos. Una vez hecho esto tenemos determinada la mayor cantidad de programadores que estan simultáneamente dentro de la empresa.
	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
	Para medir tiempos y cantidad de operaciones generamos instancias aleatorias con a lo sumo $100$ programadores.
		
	\gra{ej3_counts.png}
	\gra{ej3_times.png}

	\newpage

	\end{subsection}

\end{section}







