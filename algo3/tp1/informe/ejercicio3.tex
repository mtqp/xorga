\begin{section}{Ejercicio 3}
	
	\begin{subsection}{Explicación}
%El ejercicio planteaba el problema de obtener la mayor cantidad de programadores que están simultáneamente dentro de una empresa de software dado los horarios de ingreso y egreso de cada programador.
%Vamos recorriendo la lista de ingresos y egresos, viendo la cantidad de programadores que hay en cada horario registrado. Si cuando egresa una persona, la cantidad de programadores hasta ese momento era mayor que la cantidad máxima registrada previamente, se establece la nueva cantidad máxima. Al terminar de recorrer la lista de ingresos, 
			Para cada instancia tenemos una lista que contiene para cada programador su horario de ingreso a la empresa y otra con su horario de egreso. Además, tenemos guardado en cada momento la cantidad máxima de programadores en simultáneo.

Dado que ambas listas se encuentran ordenadas, nuestro algoritmo las recorre decidiendo a cada momento si se produce un ingreso o un egreso, es decir, si el horario que sigue en la lista de ingresos es anterior a la de egresos implica que hubo un ingreso, en caso contrario un egreso.

Cuando una persona ingresa a la empresa se incrementa el contador de la cantidad de programadores en simultáneo en el horario actual. Así, cuando se produce un egreso se compara si la cantidad de programadores dentro de la empresa previo a dicho egreso es mayor a la máxima cantidad de programadores en simultáneo hasta el momento, de ser así, actualizamos el máximo. Luego se descuenta el recientemente egresado del contador "cantidad de programadores en simultáneo".

Este procedimiento se repite hasta haber visto todos los ingresos, lo que nos garantiza tener el máximo correspondiente, ya que a partir de ese momento sólo se producirían egresos.

		\begin{subsubsection}{Análisis de complejidad}
			Elegimos el modelo uniforme para analizar la complejidad de este algoritmo porque el tamaño de los elementos es acotado y por lo tanto todas las operaciones elementales son de tiempo constante.
			
			Sea $n$ la cantidad de programadores.\\
			
			\begin{pseudo}
				\func{programadores\_en\_simultaneo}{$ingresos, egresos$}
				\tab $max,tmp,j,k \leftarrow 0$ \\
				\tab \WHILE($j< n$) & \tOde{n}  \\
				\tab \tab \IF($ingresos[j]\leq egresos[k]$) \\
				\tab \tab \tab $tmp \leftarrow tmp+1$ \\
				\tab \tab \tab $j \leftarrow j+1$ \\
				\tab \tab \ELSE \\
				\tab \tab \tab \IF($tmp>max$) \\
				\tab \tab \tab \tab $max \leftarrow tmp$ \\
				\tab \tab \tab $tmp \leftarrow tmp - 1$ \\
				\tab \tab \tab $k \leftarrow k+1$ \\
				\tab \IF($tmp>max$) \\
				\tab \tab $max \leftarrow tmp$ \\
				\tab \RET $max$
			\end{pseudo}
			Cada programador tiene un ingreso y un egreso, por lo tanto la lista de ingresos y la lista de egresos
			tienen longitud $n$. El algoritmo recorre completamente la lista de ingresos. El peor caso es 
			cuando el último ingreso y el último egreso corresponden al mismo programador, ya que para registrar éste
			último ingreso, la lista de egresos tuvo que ser recorrida hasta encontrarse con el último.
 			Por este motivo, podemos inferir que a lo sumo se realizan $2n -1$ iteraciones. En cada una de estas 
			iteraciones tenemos un costo constante de operaciones, que no modifican la complejidad en el análisis 
			asintótico.
			La complejidad algorítmica entonces, es \Ode{n}.

		\end{subsubsection}

	\end{subsection}

	\begin{subsection}{Detalles de la implementación}

	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}			
	\end{subsection}

\end{section}







