\begin{section}{Problema 3}
	\textit{Dada una lista de ingresos y otra de egresos que contienen los horarios de ingreso y egreso de cada uno de los programadores de una empresa respectivamente, determinar la mayor cantidad de programadores que estan simultáneamente dentro de la empresa.}

	\begin{subsection}{Explicación}
		Para cada instancia tenemos una lista que contiene para cada programador su horario de ingreso a la empresa y otra con su horario de egreso. Además, tenemos guardado en cada momento la cantidad máxima de programadores en simultáneo.

Dado que ambas listas se encuentran ordenadas, nuestro algoritmo las recorre decidiendo a cada momento si se produce un ingreso o un egreso, es decir, si el horario que sigue en la lista de ingresos es anterior a la de egresos implica que hubo un ingreso, en caso contrario un egreso.

Cuando una persona ingresa a la empresa se incrementa el contador de la cantidad de programadores en simultáneo en el horario actual. Así, cuando se produce un egreso se compara si la cantidad de programadores dentro de la empresa previo a dicho egreso es mayor a la máxima cantidad de programadores en simultáneo hasta el momento, de ser así, actualizamos el máximo.

Luego se descuenta el recientemente egresado del contador parcial de cantidad de programadores en simultaneo.

Este procedimiento se repite hasta haber visto todos los ingresos, lo que nos garantiza tener el máximo correspondiente, ya que a partir de ese momento sólo se producirían egresos. Este comportamiento se ve reflejado en el siguiente pseudocódigo:

		\pagebreak
		Sea $n$ la cantidad de programadores, $j$ el índice dentro de la lista de ingresos y $k$ el índice dentro de la lista de egresos.
		
		\vspace{0.5cm}
		\begin{pseudo}
				\func{programadores\_en\_simultaneo}{$ingresos, egresos$}
(1)				\tab $max,tmp,j,k \leftarrow 0$ \\
(2)				\tab \WHILE($j< n$) &   \\
(3)				\tab \tab \IF($ingresos[j]\leq egresos[k]$) \\
(4)				\tab \tab \tab $tmp \leftarrow tmp+1$ \\
(5)				\tab \tab \tab $j \leftarrow j+1$ \\
(6)				\tab \tab \ELSE \\
(7)				\tab \tab \tab \IF($tmp>max$) \\
(8)				\tab \tab \tab \tab $max \leftarrow tmp$ \\
(9)				\tab \tab \tab $tmp \leftarrow tmp - 1$ \\				(10)				\tab \tab \tab $k \leftarrow k+1$ \\
(11)				\tab \IF($tmp>max$) \\
(12)				\tab \tab $max \leftarrow tmp$ \\
(13)				\tab \RET $max$
		\end{pseudo}




	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
	Guardamos los horarios de ingreso de todos los programadores (de la misma forma que estan en el archivo de entrada, es decir, en orden creciente) en un arreglo de $strings$ (los cuales representan un horario en formato ``HH:MM:SS'') de tamaño $n$, donde $n$ es la cantidad de programadores. Además guardamos otro arreglo del mismo tamaño con los horarios de egreso.
	
	A medida que vamos recorriendo los arreglos $ingresos$ y $egresos$ necesitamos decidir si el horario de ingreso del programador $j$ es anterior o posterior al horario de egreso del programador $i$, esto lo hacemos comparando los $strings$ por menor o igual (que el horario de ingreso del programador $j$ sea el mismo que el horario de egreso del programador $i$ significa que ambos estuvieron en simultáneo en la empresa jústamente en ese horario ya que se considera que un programador permanece dentro de la empresa desde su horario de ingreso hasta su horario de egreso, incluyendo ambos extremos). Si la comparación resulta verdadera significa que el programador $j$ ingresa a la empresa por lo que incrementamos el contador de programadores en simultáneo en ese horario. En caso contrario lo decrementamos ya que el programador $i$ egresa. Antes de decrementar dicho contador verificamos si la cantidad de programadores en simultáneo previo al egreso de $i$ es mayor a $max$ (máxima cantidad de programadores en simultáneo calculada hasta el momento) y de ser necesario actualizamos $max$.

	Una vez que terminamos de recorrer la lista de ingresos, actualizamos $max$ ya que desde el último egreso visto se pueden haber producido nuevos ingresos. Una vez hecho esto tenemos determinada la mayor cantidad de programadores que estan simultáneamente dentro de la empresa.
	\end{subsection}

	\begin{subsection}{Análisis de complejidad}
			Elegimos el modelo uniforme para analizar la complejidad de este algoritmo porque el tamaño de los elementos es acotado y por lo tanto todas las operaciones elementales son de costo constante.\Pa
			
			Sea $n$ la cantidad de programadores, $j$ el indice dentro de la lista de ingresos y $k$ el indice dentro de la lista de egresos.\\
			
			
			Cada programador tiene un ingreso y un egreso, por lo tanto la lista de ingresos y la lista de egresos tienen longitud $n$.

El algoritmo en todos los casos recorre completamente la lista de ingresos, por lo que el peor caso es cuando el último ingreso y el último egreso corresponden al mismo programador, ya que para registrar éste último ingreso, tambien tuvo que recorrer toda la lista de egresos. Por este motivo, podemos inferir que a lo sumo se realizan $2n -1$ iteraciones. En cada una de estas tenemos un costo constante de operaciones, que no modifican la complejidad en el análisis asintótico. La complejidad algorítmica en el modelo uniforme entonces es \Ode{n}.\VSP

		\noindent\textbf{En función del tamaño de la entrada}\\

			Como los elementos de ambas listas son de tamaño acotado, el tamaño de la entada es proporcional a la longitud de las listas (n). Entonces la complejidad del algoritmo es \Ode{t}, donde $t$ es el tamaño de la entrada. La complejidad del algoritmo es lineal.
	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
	Las entradas utilizadas para probar correctitud estián en el archivo \texttt{pruebas.in}. Fueron elegidas para probar casos bordes como son: un solo programador, primero ingresan todos y luego empiezan a egresar, un ingreso se produce exactamente al mismo horario que un egreso, cada ingreso seguido del egreso correspondiente y por último ingresos y egresos mezclados.

	En los gráfico se verán, en rojo la cantidad de operaciones realizadas o el tiempo transcurrido durante la ejecución del algoritmo para una cantidad de programadores dada. Se busca con esto comprobar lo analizado anteriormente, que dicha función se pueda ver acotada por alguna recta, dibujada en color verde.

	Los primeros dos gráficos muestran el comportamiento del algoritmo para un rango de 1 a n programadores que entran y salen antes de que haya un nuevo ingreso, es decir, nunca habrá más de un programador en simultáneo. Para esto se cuenta con un generador que crea instancias de este tipo de 1 a N. La recta graficada se corresponde con SARASA.

	GRAFICO 1, GRAFICO 2

	En los siguientes dos gráficos se mostrarán casos donde primero ocurran todos ingresos y luego los egresos. Se espera ver el mejor caso, donde si bien la complejidad se mantiene lineal, es mínima la cantidad de operaciones, ya que al producirse todos los ingresos el algoritmo termina sin recorrer la lista de egresos. Para esto se usó un generador de instancias.

	GRAFICO 1, GRAFICO 2

	Para los ultimos gráficos utilizamos un generador aleatorio de instancias, que dado un número máximo de programadores $n$, genera instancias aleatorias con a lo sumo $n$ programadores. Corrimos el generador con $n$ igual a cien, esperando ver el comportamiento del algoritmo en los casos anteriores y casos promedio,y así poder cotrastarlos.


	\gra{ej3_counts.png}\VSP

	
	
	\gra{ej3_time.png}\VSP

	
	 Se puede observar que ambos gráficos se encuentran acotadas por la rectas de los casos donde todos los ingresos precedían a los egresos. Con lo cual se corrobora empiricamente que el pero caso coincide con lo analizado previamente. 
	En ambos gráfico, se observa que hay una distribución muy similar, sólo que en este se muestra el tiempo consumido para procesar cada instancia en función de la cantidad de programadores.\\

	Lo que obsevamos en los gráficos tiene coherencia con la complejidad teórica calculada. 
	En general, vemos que el algoritmo se comporta como \Thetade{n} ya que como mínimo recorre sólo toda la lista de ingresos y como máximo recorre tanto la lista de ingresos como la de egresos. Es decir, el costo del algoritmo esta acotado inferior y superiormente por $c*n$, con c constante.

	\end{subsection}

\end{section}







