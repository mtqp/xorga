\begin{section}{Problema 1}

	\textit{Dados $b,n \in \mathbb{N} $ calcular $b^n\; mod\; n$}

	\begin{subsection}{Explicación}

		Una solución factible al problema es utilizar un algoritmo recursivo basado en la técnica $Divide \& Conquer$.
		La idea seria quedarnos cada vez con un problema más chico, dividiendo el exponente a la mitad y resolver recursivamente dicho problema hasta llegar a uno suficientemente chico (en este caso $n==2$) para luego combinar las soluciones elevando al cuadrado lo ya calculado y obtener así una solución al problema original. En el caso donde $n$ fuese impar se resuelve el problema para $n-1$ a través del mismo procedimiento y luego se multiplica el resultado por $b$.

		Para la resolución del problema decidimos utilizar un algoritmo iterativo frente a uno recursivo debido al uso que este último hace de la pila, lo cual implica repetidos accesos a memoria disminuyendo asi la performance del algoritmo.

		En cada iteración el algoritmo divide el exponente a la mitad y eleva al cuadrado el acumulador (en la primer iteración $b$). Cuando llega a un exponente impar multiplica el resultado por el acumulador y continua elevando dicho acumulador. Cuando el exponente llega a uno repite lo anterior y termina. Es decir, el resultado es la productoria de los resultados parciales obtenidos en los exponentes impares.

		Al tener un acumulador que nos guarda las potencias ya calculadas el algoritmo evita hacer calculos repetidos y logra minimizar la cantidad de multiplicaciones.

		Tanto la versión recursiva como la iterativa toman módulo $n$ luego de cada multiplicación para asegurarse que el resultado entra en el tamaño de la variable (suponiendo que $n-1\times n-1$ entra).


		\begin{subsubsection}{Análisis de complejidad}
		Esta vez, elegimos un modelo logarítmico para analizar el algoritmo, ya que las operaciones que aplicamos, en teoría, dependen del logaritmo del número en cuestión, o dicho de otra forma, del tamaño de la entrada. No obstante, en los resultados muchas de ellas tienen costo uniforme por trabajar con números de tamaño acotado (\texttt{unsigned long long int}) para simplificar la implementación.\Pa

		Sea $m = n$ \\

		\begin{pseudo}
			\WHILE{$m>0$} & \tOde{\log^3 n} \\
			\tab \IF{ $m$ es impar } & \tOde{\log m} \\
			\tab \tab $tmp \leftarrow tmp * b$ & \tOde{\log^{2}n} \\
			\tab \tab $tmp \leftarrow tmp\; mod\; n$ & \tOde{\log^{2}n} \\
			\tab $m \leftarrow \frac{m}{2}$ & \tOde{\log m} \\
			\tab $b \leftarrow b^2$ & \tOde{\log^{2} n} \\
			\tab $b \leftarrow b\; mod \; n$ & \tOde{\log^{2} n} \\
			\RET $tmp$
		\end{pseudo}
		
		\noindent\textbf{Cantidad de operaciones}\\

		\begin{center}
		\begin{tabular}{rlcl}
			1er&iteración & $\rightarrow$ & $m = n$ \\
			2da&iteración & $\rightarrow$ & $m = \frac{n}{2}$ \\
			3er&iteración & $\rightarrow$ & $m = \frac{n}{2^2}$ \\
			4ta&iteración & $\rightarrow$ & $m = \frac{n}{2^3}$ \\
			&\vdots&&\vdots \\
			$k$-ésima&iteración & $\rightarrow$ & $m = \frac{n}{2^{k-1}} = 1$  
		\end{tabular}
		\end{center}

		\noindent Como el algoritmo termina cuando $m=1$ entonces, \\
		\begin{eqnarray*}
			\frac{n}{2^{k-1}}&=& 1 \\
			n &=& 2^{k-1} \\
			\log n &=& \log\; 2^{k-1} \\
			\log n &=& k-1 \Rightarrow k = \log( n )+1
		\end{eqnarray*}

		\noindent es decir, hace $\log(n)+1$ iteraciones, cada una con una cantidad constante de operaciones.

		Por lo tanto, la cantidad de operaciones que hace el algoritmo es del orden de $\log n$ y \Ode{\log n} $\subset$ \Ode{n}.

		\vspace{0.5cm}
		\noindent\textbf{Complejidad en el modelo logarítimico}\\

Como $m\leq n$ y la función logaritmo es estrictamente creciente, $\log m \leq \log n$. De la misma manera, $\log b$ y $\log tmp$ están acotados por $\log n$. Por lo tanto, la complejidad en el modelo logarítmico es: \\
\Ode{\log(n)*(\log(n)+\log^2(n)+\log^2(n)+\log(n)+\log^2(n)+\log^2(n))} $=$ \\
$=$ \Ode{\log(n)*(2\log(n)+4\log^2(n))} $=$ \Ode{2\log^2 n + 4\log^3 n} \\

Luego, por definición, 
			\begin{center}
				\Ode{2\log^2 n + 4\log^3 n} $=$ \Ode{max(2\log^2 n , 4\log^3 n)} $=$ \Ode{\log^3 n}.
			\end{center}

			%La complejidad del algoritmo en el modelo logarítmico es: \\
%(1) \Ode{\log(n) * (\log(m)*\log(2)+\log(tmp)*\log(b)+\log(tmp)*\log(n)+\log(m)*\log(2)+\log^2(b)+\log(b)*\log(n))}

%			Como $m\leq n$ y la función logaritmo es estrictamente creciente, $\log m \leq \log n$. De la misma manera $\log b$ y $\log tmp$ están acotados por $\log n$. Por lo tanto,

%(1) $\leq$ \Ode{\log(n)*(\log(n)+\log^2(n)+\log^2(n)+\log(n)+\log^2(n)+\log^2(n))} $=$ \Ode{\log(n)*(2\log(n)+4\log^2(n))} $=$ \Ode{2\log^2 n + 4\log^3 n}

%		Por definición, \Ode{2\log^2 n + 4\log^3 n} $=$ \Ode{max(2\log^2 n , 4\log^3 n)} $=$ \Ode{\log^3 n}.
		Entonces, la complejidad del algoritmo resulta ser: \Ode{log^3 n}\VSP
		
		\noindent\textbf{En función del tamaño de la entrada}\\

			El tamaño de la entrada $t$ es $\log n$ ya que $b$ es acotado ($n=2^t$). Entonces la complejidad del algoritmo en función del tamaño de entrada es: \Ode{\log^3 2^t}=\Ode{t^3}.

		\end{subsubsection}
	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		La siguiente tabla representa la correspondencia entre las variables de entrada ($b$ y $n$) en cada iteración del algoritmo implementado:

		\vspace{0.5cm}
		\begin{center}
		\begin{tabular}{|l|c|c|c|c|c|}
			\hline
			iteración   & $1$ & $2$           & $3$             & ... & $k$ \\
			\hline
			$n$         & $n$ & $\frac{n}{2}$ & $\frac{n}{2^2}$ & ... & $\frac{n}{2^{k-1}}$ \\
			\hline
			$b$         & $b$ & $b^2$         & $b^4$           & ... & $b^{2^{k-1}}$ \\
			\hline
		\end{tabular}
		\end{center}

		\vspace{0.5cm}
		\noindent Sean \\
		\indent
		\begin{tabular}{ll}
			$A_k = \frac{n}{2^{k-1}}$ & bla bla bla, y \\
			$Z_k = impar(A_k) * b^{2^{k-1}}$ $^{[2]}$ & la sucesión que tiene los valores de $b$ correspondientes a los $n$ impares
		\end{tabular} \\
		\vspace{0.2cm}
		entonces el cálculo hecho por el algoritmo está dado por 
		$$\displaystyle\prod_{i=1}^k Z_i = b^n$$

\noindent Además, luego de cada multiplicación toma el módulo ya que
 $$b^k * b^{n-k}\; mod\;n = (b^k\;mod\;n)*(b^{n-k}\;mod\;n)\;\forall\;k\leq n ^{[1]}$$

De esta manera, incluso si el cálculo de $b^n$ es un número tan grande que no entra en el tamaño de la variable, se va a poder realizar sin problemas (suponiendo que $(n-1)^2$ entra en una variable).

\vspace{0.5cm}
\noindent{\footnotesize [1] impar se define como:
\begin{displaymath}
	impar(x)=\left\{
	\begin{array}{ll}
		1 & $si $x$ es impar$ \\
		0 & $sino$
	\end{array}\right.
\end{displaymath}
} \\
{\footnotesize [2] Por propiedades del módulo $x*y\; mod \; z = (x\; mod\; z)*(y\; mod\; z)$ } \\


	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
	
		\gra{ej1_counts}\Pa
		\gra{ej1_times}

	\end{subsection}

\end{section}

