\begin{section}{Algoritmo exacto}
		\begin{subsection}{Explicación}
			El Algoritmo busca todas las formas de armar una clique utilizando la técnica de backtracking. Para esto, inicia la clique una vez desde cada vértice probando todas las combinaciones que lo incluyan, agregando vértices tal que forman un completo con los ya incluídos. Se necesita empezar una vez por cada nodo ya que la solución final podría no incluir el nodo inicial. De esta forma, se genera un árbol de backtracking teórico para cada vértice inicial. Mediante podas, evita recorrer el árbol por completo, siendo la solución final la máxima de las cliques encontradas. Como el algoritmo busca todas las cliques del grafo, la solución es la clique máxima del grafo.

		\begin{subsubsection}{Optimizaciones}
			Dado que se trata de un algoritmo de backtracking, la optimzación se basa en podar las ramas en las que estamos seguros que no va a aparecer el óptimo. Para esto tenemos que poder predecir, dado un estado actual, si es posible mejorar el óptimo encontrado hasta el momento.
			
			Por un lado, podamos las ramas que no forman un grafo completo, ya que no es solución.
			
			Por otro lado, evaluamos en cada paso del algoritmo la cantidad de vértices que falta explorar. Es decir, calculamos el tamaño de la clique máxima que podríamos formar considerando los vértices que ya estan incluídos en la solución actual. Si la cantidad de vértices que todavía no fueron evaluados más la cantidad de vértices ya pertenecientes a la clique actual es menor a la cantidad de vértices de la clique máxima encontrada hasta el momento, no tiene sentido seguir explorando esa rama ya que el tamaño de la clique máxima que se puede encontrar por ese camino es menor al tamaño de la máxima encontrada. Por este motivo, podamos esta rama.

			Además, para cada vértice que inicia la clique se intenta agregar los de mayor numeración tal que forman un completo. Por lo tanto, se evita repetir combinaciones. Supongamos que tenemos una clique de tres vértices, siendo estos el $<1,2,3>$. Con esta optimización, nunca han de analizarse los casos $<2,3,1>$; $<2,1,3>$; $<3,1,2>$ y $<3,2,1>$.
		\end{subsubsection}

		\end{subsection}
		\begin{subsection}{Detalles de la implementación}
			
			Almacenamos las relaciones entre los vértices en una matriz de $n \times n$, donde $n$ es la cantidad de vértices. Cada posición $(i,j)$ de la matriz contiene un $uno$ si existe la arista $(i,j)$ y un $cero$ en caso contrario. De esta forma se le asigna un número a cada vértice.

			A continuación, se muestra el pseudocódigo del algoritmo exacto.\\
			
			\begin{pseudo}
				\func{exacto}{matriz\_adyacencia,n}
				\tab $solucion \leftarrow \emptyset$\\
				\tab $\FOR i \TO n$\\
				\tab \tab buscar clique máxima desde el vértice $i$\\
				\tab \tab $\IF$ tiene más vértices que $solucion$\\
				\tab \tab \tab $solucion \leftarrow $ clique encontrada\\
				\RET $\#(solucion)$\\
			\end{pseudo}
			
			El algoritmo de backtracking recorre todos los vértices. Para cada uno de estos verifica si es adyacente con todos los vértices de la solución actual y si todavía no pertenece a la misma. Si es así lo agrega y repite este procedimiento (avanza). Si no, significa que recorrió todos los vértices y no logró formar una clique mayor a la encontrada, por lo que comienza a retroceder.

			Cuando retrocede, saca el último vértice $v$ que agregó a la solución y prosigue la búsqueda desde el vértice siguiente a $v$ en numeración. Si no hay un vértice que se pueda agregar, es decir, si ninguno de los siguientes forma una clique, el algoritmo sigue retrocediendo.
			
		\end{subsection}


		\newpage
		
		\begin{subsection}{Complejidad temporal}

		El algoritmo exacto utiliza la técnica de backtracking, con lo que genera un árbol donde cada rama es una posible solución, podando cuando considere que por ese camino no encuentra solución, o no encuentre una mejor a la actual.
		Dar la cota de complejidad de este algoritmo es complicado si tuviésemos en cuenta las podas que se realizan en el backtracking. Si quisieramos ajustar la cota, deberíamos buscar un grafo particular tal que las minimice (las podas), maximizando así la cantidad de vértices del árbol de backtracking.
		Por este motivo decidimos plantear un caso hipotético donde el árbol de backtracking se genere sin podas, verifícando para cada nodo $i$ las posibles cliques que lo contengan, intentando incluir sólo los de mayor numeración para no repetir soluciones. Como dijimos, esto es un caso hipotético, donde el algoritmo tiene un comportamiento menos eficiente que el real, y de esta forma conseguimos una cota superior poco ajustada, pero que a los fines prácticos nos da una idea de que aún en el peor caso, el algoritmo será más eficiente respecto a la cota calculada. 

		De esta forma el algoritmo verifica para cada vértice $i$, con $0 < i < n$, las cliques posibles que lo contengan, es decir, todas las combinaciones que tengan a $i$ más otros vértices entre $i$ y $n$ tal que forman una clique.

		Así, para cada vértice $i$ genera un árbol donde cada rama representa una clique que lo incluye, por lo que tendremos un árbol de $n-i$ factorial vértices.

		Como este procedimiento se repite con $i$ desde 1 hasta $n$ nos queda planteada la siguiente sumatoria: $\sum_{i=1}^{n}{i!}$ = $1! + 2! + 3! + ... + n!$

		Entonces la complejidad viene dada por: \Ode{1! + 2! + 3! + ... + n!}= \Ode{max(1!,2!,3!,...,n!)}= \Ode{n!}
		
		
		\end{subsection}
\end{section}

