\begin{section}{Problema 1}

	\textit{enunciado}

	\begin{subsection}{Explicación}

		La resolución del problema consiste en considerar cada uno de los elementos de la secuencia dada como
		posible máximo de una subsecuencia (al que nos referiremos como ``pico"), tal que sea unimodal. Cada 
		subsecuencia unimodal tiene longitud máxima, es decir, contiene la subsecuencia creciente hasta el pico
		y la subsecuencia decreciente desde el pico, ambas con la mayor cantidad de elementos posibles. Al no
		necesitar explicitar los elementos de la secuencia, la única información que aporta a la solución del
		problema es la longitud de cada subsecuencia. De esta manera, para determinar la mínima cantidad de
		elementos que se deben eliminar para transformar la secuencia dada en unimodal, basta con conocer
		la diferencia entre la longitud de la secuencia original y el máximo de las longitudes de cada
		subsecuencia unimodal. 		

	\end{subsection}


	\begin{subsection}{Detalles de la implementación}
		
		Para determinar la máxima longitud de la subsecuencia creciente y decreciente hasta cada elemento,
		utilizamos la técnica de programación dinámica.
		
		Sea la secuencia dada $S=[s_1,s_2,...,s_n]$ y $C=[c_1,c_2,...,c_n]$ \\
		con $c_i=\displaystyle\max_{0<j<i}\{ c_j / s_j < s_i \}+1$ ($\forall\;i\in\mathbb{N}, 0<i\leq n$), es 
		decir, para cada $i$ tenemos en $c_i$ la máxima longitud de la subsecuencia creciente que incluye a
		$s_i$. Análogamente, se define $D$ como la secuencia que contiene las máximas longitudes de las
		subsecuencias decrecientes de $S$.
		
		El algoritmo que calcula la solución implementa tanto $C$ como $D$.	
		Para obtener la máxima longitud de la subsecuencia creciente hasta el índice $i$, itera
		por todos los índices $j<i$ en $C$, buscando el máximo valor entre los $c_j$ tales que $s_i$ sea mayor
		que	$s_j$. 
		Esto asegura que en la posición $c_i$ está la máxima longitud de la subsecuencia creciente
		que incluye a $s_i$ ya que, si existiese otra subsecuencia de mayor longitud a la que se pueda 
		agregar $s_i$, se podría agregar el $s_i$ a esa secuencia y así obtener una con más cantidad de 
		elementos, siendo el valor de $c_i$ la longitud de dicha secuencia más 1. Para calcular $D$,
		invertimos $S$ y aplicamos el mismo	procedimiento que para $C$, quedando en $d_i$ la máxima longitud
		de la subsecuencia decreciente que incluye a $s_{n-i}$.

		Luego de calcular $C$ y $D$ el algoritmo determina la mínima cantidad de elementos a ser eliminados de
		la secuencia tales que el resto de los elementos forman una secuencia unimodal, de la siguiente forma:
		
		\vspace{0.5cm}
		\begin{pseudo}
			\func{secuencia\_unimodal}{$secuencia,C,D$}
			\tab $max\_long \leftarrow 0$ \\
			\tab \FOR $i=1$ \TO $n$ \\
			\tab \tab $long\_secuencia\_unimodal\leftarrow C[i]+D[n-i]-1$ \\
			\tab \tab \IF $ long\_secuencia\_unimodal >  max\_long$ \\
			\tab \tab \tab $max\_long \leftarrow long\_secuencia\_unimodal$ \\
			\tab \RET longitud($secuencia$)-$max\_long$
		\end{pseudo}

	\end{subsection}


	\begin{subsection}{Análisis de complejidad}
	Como hemos visto anteriormente, nuestro algoritmo utiliza la técnica de programación dinámica. Esta consta de reutilizar información previa para llegar al resultado final. En el análisis de la complejidad veremos como la aplicación de la técnica previamente mencionada, ha permitido conseguir un algoritmo polinomial.\\
	
	El algoritmo $long\_max\_creciente$ que calcula para cada elemento $i$ de la secuencia original la máxima longitud de la secuencia creciente y decreciente que lo incluye, itera por todos los índices $j<i$ ($\forall\; 0 \leq i < n$).\\

	La complejidad de dicho algoritmo viene dada por: $\sum_{i=0}^{n-1} i = \frac{n*(n-1)}{2} = ESTA SUMATORIA DA DEL OOOODEN DE ene cuadrado, OJO AHI LA PIPETUa... n^2$\\

	Sea $n$ la longitud de la secuencia dada, $max\_long\_creciente$ la secuencia que guarda en cada posición la máxima longitud de la subsecuencia creciente.\\

	\begin{pseudo}
		\func{long\_max\_creciente}{$secuencia, max\_long\_creciente$}
		\tab $max\_long\_creciente[0] \leftarrow 0$ \tab \tab \Ode{1} \\
		\tab \FOR $i=1$ \TO $n$ \\
		\tab \tab $max\_long \leftarrow 0$ \tab \tab \tab \tab \Ode{1} \\
		\tab \tab \FOR $j=i-1$ \TO $0$ \tab \Ode{i}\\
		\tab \tab \tab \IF $ secuencia[j] <  secuencia[i] \AND max\_long\_creciente [j] > max\_long)$ \Ode{1} \\
		\tab \tab \tab \tab  $max\_long \leftarrow max\_long\_creciente[j] $ \tab \Ode{1} \\
		\tab $max\_long\_creciente[i] \leftarrow max\_long+1$ \tab \tab \tab \Ode{1} \\
	\end{pseudo}

	Podemos ver dentro de cada ciclo ($for$) que todas las asignaciones tienen costo constante, así como también la guardar del ($if$). De esta manera podemos concluir que por cada iteración del ($for$) anidado tenemos en el peor caso el costo de la guarda del if, más el costo de la asignación adentro del mismo, con costo constante.\\
	El ciclo anidado iterará para cada $i$, $i-1$ veces, siendo los valores posibles de $i$ desde $1$ hasta $n$.\\
	La sumatoria que fue descripta anteriormente, se coindice entonces con el costo de la función $long\_max\_creciente$. La cantidad de operaciones que realiza este algoritmo es \Ode{n^2}.\\
	
	El algoritmo encargardo de devolver el resultado del problema se llama $secuencia\_unimodal$ la cual utiliza el algoritmo descripto anteriormente y realizar algunas otras operaciones que se detallarán a continuación para concluir con el análisis de complejidad.\\
	
	\end{subsection}


	\begin{subsection}{Pruebas y Resultados}

	\end{subsection}

\end{section}

