\begin{section}{Problema 3}

	\textit{Bernardo se encuentra en una prisión que consta de $n$ habitaciones conectadas por $m$ pasillos. Cada pasillo conecta exactamente $dos$ habitaciones y puede ser transitado en ambas direciones. En toda la prisión hay $p$ puertas, cada una puede abrirse con una única llave. Tanto las puertas como las llaves están repartidas en las habitaciones, de tal forma que cada habitación puede tener una única puerta o almacenar una única llave, pero no ambas cosas. Si una habitación tiene puerta, la llave correspondiente es necesaria para entrar a la habitación, independientemente del pasillo que se use para llegar a la misma. Bernardo se encuentra en la habitación $uno$, mientras que desde la habitación $n$ es posible salir de la prisión. Decidir si Bernardo puede recorrer las habitaciones recolectando llaves y abriendo puertas de manera tal de llegar a la habitación $n$ y asi escapar.}
		
	\begin{subsection}{Explicación}
		Bernardo recorre las habitaciones que tengan conexión con la habitación donde se encuentra, siempre y cuando pueda entrar, ya sea porque tiene la llave o porque la habitación no tiene puerta. Su procedimiento continúa hasta que:
		\begin{itemize}
			\item Llega a la habitación $n$, por lo tanto encontró la salida.
			\item Se le terminan los accesos a las habitaciones vecinas y por lo tanto no puede escapar.
		\end{itemize}

	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		Modelamos este problema con un grafo donde los vértices corresponden a las habitaciones (puede ser una habitación con una llave dentro, con una puerta o sin puerta ni llave) y las aritas a los pasillos.\\	

		Generamos la matriz de adyacencia del grafo (de $n\times n$ donde $n$ es la cantidad de habitaciones donde cada posición $(i,j)$ de la matriz contiene un $uno$ si la habitación $i$ está conectada con la habitación $j$ y $cero$ en caso contrario). Nos referiremos a la matriz como $conexiones$.\\

		Para toda habitación que tenga puerta existe una llave. Poseer esta llave implica tener la posibilidad de acceder a la habitación. Podemos abstraernos del problema de Bernardo y considerar a las llaves como valores booleanos en un arreglo que nos dice para cada vértice, si este es accesible o no. Tenemos entonces, un arreglo de tipo bool ($tengo\_llave$) de tamaño $n$ donde cada vértice, representado por el índice de dicho arreglo, esta seteado en $verdadero$ si es accesible y en $falso$ sino.

		Por otro lado, tenemos un arreglo $puertas$ de tamaño $n$ (siendo $n$ es la cantidad de vértices del grafo), donde cada posición, si corresponde a una habitación con llave, tiene el vértice al cual habilita el acceso. En caso contrario, el arreglo contiene el valor $cero$. El valor es $cero$, porque como se verá más adelante en el pseudocódigo, modificará información del primer vértice, que a los fines prácticos, no modifica el resultado final del algoritmo.
		
		También tenemos un arreglo de bools llamado $enEspera$ el cual esta inicializado en falso si el vértice $i$ no puede ser accedido (tiene puerta), y en verdadero en caso contrario. Entonces, para cada vértice, de existir una posible restriccion de acceso, su posición permanece en falso.\\

		Para la resolución del problema recorrimos el grafo de forma ordenada por niveles. Para esto hicimos una modificación al algoritmo $Breadth\; First\; Search$. La modificación consiste en visitar los vértices adyacentes al 'actual' tales que todavía no fueron visitados y tienen acceso permitido, cuando esto último no ocurre se pone el vértice en 'espera' hasta que por otro camino se encuentre al vértice que habilite el acceso al mismo. Al momento de conseguir el acceso a un vértice que se encuentra en 'espera' se lo accede directamente (sin volver a pasar por los vértices que llevan a él) considerando posible ese camino hacia el vértice $n$. Cabe destacar que este algoritmo puede acceder a cada vértice sólo una vez.\\ 

		El objetivo del $bfs$ es llegar desde el primer vértice al último.\\
		
		El siguiente pseudocódigo refleja el comportamiento previamente descripto:\\

		\begin{pseudo}
		\func {prision}{$conexiones, tengo\_llave, puertas, n$}
		\tab $llegue \leftarrow false$\\
		\tab $cola\; q$\\
		\tab $visitados[0..n] \leftarrow false$\\ 
		\tab $enEspera[0..n] \leftarrow false$\\ 
		\tab $encolar(q,0)$\\
		\tab $visitados[0] \leftarrow true$\\
		\tab \WHILE $!esVacia(q) \AND !llegue$\\
		\tab \tab $actual \leftarrow primero(q)$\\
		\tab \tab $desencolar(q)$\\
		\tab \tab \FOR $ i\leftarrow0 \TO n \AND !llegue$\\
		\tab \tab \tab \IF	$conexiones[actual][i] \AND tengo\_llave[i] \AND !visitados[i]$\\
		\tab \tab \tab \tab	$tengo_llave[puertas[i]] \leftarrow true$\\
		\tab \tab \tab \tab	$encolar(q,i)$\\
		\tab \tab \tab \tab	$visitados[i] \leftarrow true$\\
		\tab \tab \tab \tab	$llegue \leftarrow (i == n-1)$\\
		\tab \tab \tab \tab \IF	$enEspera[puertas[i]]$\\
		\tab \tab \tab \tab \tab $encolar(q,puertas[i])$\\
		\tab \tab \tab \tab \tab $visitados[puertas[i]] \leftarrow true$\\
		\tab \tab \tab \tab \tab $llegue \leftarrow (n-1==puertas[i])$\\
		\tab \tab \tab \ELSE \\
		\tab \tab \tab \tab \IF $conexiones[actual][i] \AND !visitados[i]$\\
		\tab \tab \tab \tab \tab $enEspera[i] \leftarrow true$\\
		\tab \RET $llegue$\\
		\end{pseudo}

		En pocas palabras, la idea del algoritmo es explorar el grafo con $bfs$ en busca de un camino que inicie en el vértice $cero$ y llegue al vértice $n$, si se encuentra con un vértice que no es accesible, espera hasta que desde otro camino se habilite la entrada a ese vértice, una vez habilitada continua por ese camino, mientras sigue recorriendo todo camino que se encuentre habilitado hasta el momento.\\

		El resultado final viene dado por la variable $llegue$. Es inicializada en $falso$ y se setea en $verdadero$ si sólo si en algún momento el vértice a encolar es el $n$ ($i == n-1$), es decir, el vértice $n$ fue alcanzado por el $bfs$. Si esto ocurre, podemos concluir que pudimos llegar al vértice objetivo. Si pasa por todos los vértices habilitados y los que pudo habilitar y no puede llegar al vértice $n$, sale del ciclo (\textbf{while}) sin cambiar el valor de $llegue$ y devuelve $falso$.\\
		
	\end{subsection}


	\begin{subsection}{Análisis de complejidad}
		Como mencionamos previamente, el algoritmo \textbf{no} podrá pasar más de una vez por cada vértice. Mientras quede algun vértice por ver y pueda accederse, seguirá intentando llegar al nodo $n$. Analizando la complejidad, vemos que si el $bfs$ pudiera acceder indistitamente a todos los vértices del grafo, el ciclo $while$ tendría un costo de $n$ iteraciones.\\
		
		Dentro del ciclo principal tenemos las primeras dos operaciones con costo constante (una asignación y quitar de la pila el primer elemento), y un ciclo anidado ($for$).\\
		
		Por lo tanto tenemos hasta el momento $n$ interaciones del ciclo $while$ donde dentro de él tenemos un ciclo $for$. Una primer aproximación a la complejidad final sería pensar que para cada una de las $n$ iteraciones tendremos un costo $h$ todavia no conocido por el ciclo $for$, descartando para complejidad el costo constante de la asignación y quitar el primer elemento de una pila. Tenemos hasta ahora, \Ode{n*h}.\\
		
		Analizemos ahora la cantidad de operaciones a la que equivale $h$ en el peor caso.\\
		
		El ciclo for itera en el peor caso desde $0$ hasta $n$ (puede salir antes si el valor de la variable bool $llegue$ se setea en verdadero). Por lo tanto tenemos que $h$ será a lo sumo $n*c$ (con $c$ constante) porque dentro de este ciclo anidado, se asignan valores a arreglos, matrices, se encolan parametros constantes a pilas, se setean valores booleanos y se chequea guardas de condicionales $if$ y todas estas operaciones tienen costo constante. Cabe aclarar que la cantidad de veces que se realizan estas operaciones por cada iteración también es constante, por lo que se puede deducir que una iteración del ciclo $for$ tiene costo constante. Es así entonces que $h = n*c$.\\
		
		Continuando con el análisis de complejidad, teníamos que el algoritmo tenia complejidad de \Ode{n*h}, siendo ahora $h=n*c$. Por lo tanto, la complejidad de este algoritmo es \Ode{n*n*c} = \Ode{n^2} $\subset$ \Ode{n^3}\\
	\end{subsection}


	\begin{subsection}{Pruebas y Resultados}
		Para probar correctitud contamos con un generador de instancias en las cuales Bernardo puede escapar y otras en las cuales no, que nos devuelve un archivo $test\_libre.in$ y $test\_no.in$ respectivamente. De esta forma, con una comparación de archivos (comando \texttt{make diffs} en la carpeta Ej3) podemos saber para cada instancia si el resultado obtenido por nuestro algoritmo es correcto.

		Para analizar la complejidad temporal del algoritmo (cantidad de operaciones) tenemos un generador aleatorio de 'mapas' donde para cada número de habitaciones $n$ variamos el porcentaje de pasillos con respecto al máximo (es decir, variamos la densidad del grafo). Generamos para cada $n$ desde $4$ a $100$ ($4$ por enunciado y $100$ porque nos pareció suficente para comprobar el comportamiento del algoritmo), $10$ casos con densidad $0.3$ y $0.6$ y $1$ con densidad $0.9$, decidimos hacer sólo una instancia de densidad $0.9$ por cada $n$ porque la variedad de instancias posibles para esa densidad es baja y la probabilidad de que se repitan alta porque nos pareció que no tenia sentido hacer más.\\
		Por otro lado, generamos peores casos para el algoritmo $\forall n\; 4 \leq n \leq 100$ por motivos ya mencionados. Para generar peores casos armamos un árbol donde la raíz es la habitación  $uno$, desde donde inicia $Bernardo$. Si $n$ es par, en el nivel $uno$  hay $\frac{(n-2)}{2} + 1$ habitaciones donde $\frac{(n-2)}{2}$ corresponden a las que tienen puertas y el restante tiene la llave de la habitación $\frac{(n-2)}{2} + 1$ y en el nivel $dos$ estan el resto de las habitaciones, es decir, las habitaciones que tienen las llaves y la habitación $n$. Si $n$ es impar, 

		\gra{prision/count_test_peor_caso.pdf}		
		\gra{prision/count_test_densidades.pdf}

		
	\end{subsection}

\end{section}

