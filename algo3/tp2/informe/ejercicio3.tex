\begin{section}{Problema 3}

	\textit{enunciado}

	\begin{subsection}{Explicación}
		Como Bernardo puede pasar más de una vez por cada habitación el algoritmo restringe el acceso a cada una de estas, podrá acceder a cada habitación tantas veces como pasillos llegan a la habitación.
		Bernardo recorre las habitaciones que tengan conexión con la habitación donde se encuentra, siempre y cuando pueda entrar, ya sea porque tiene la llave o la habitación no tiene puerta y además, todavía tiene acceso a la habitación a entrar. Su procedimiento continúa hasta que:
		\begin{itemize}
			\item Llega a la habitación $n$, por lo tanto encontró la salida.
			\item Se le terminan los accesos a las habitaciones vecinas y por lo tanto no puede escapar.
		\end{itemize}

	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		Modelamos este problema con un grafo donde los vértices corresponden a las habitaciones (puede ser una habitación con una llave dentro, con una puerta o sin puerta ni llave) y las aritas a los pasillos.\\	

		Generamos la matriz de adyacencia del grafo (de $n\times n$ donde $n$ es la cantidad de habitaciones donde cada posición $(i,j)$ de la matriz contiene un $uno$ si la habitación $i$ está conectada con la habitación $j$. y $cero$ en caso contrario). Nos referiremos a la matriz como $conexiones$.\\

		Para toda habitación que tenga puerta existe una llave. Poseer esta llave implica tener la posibilidad de acceder a la habitación. Podemos abstraernos del problema de Bernardo y considerar a las llaves como valores booleanos en un arreglo que nos dice para cada vértice, si este es accesible o no. Tenemos entonces, un arreglo de tipo bool ($tengo\_llave$) de tamaño $n$ donde cada vértice, representado por el índice de dicho arreglo, nos dice si es accesible o no.\\

		Por otro lado, tenemos un arreglo $puertas$ de tamaño $n$ (donde $n$ es la cantidad de vértices del grafo), donde cada posición, si corresponde a una habitación con llave, tiene el vértice al cual habilita el acceso. En caso contrario, el arreglo contiene el valor $0$. El valor es cero, porque como se verá más adelante en el código, modificará información del primer vértice, que a los fines prácticos, no modifica el resultado final del algoritmo. ESTO CAPAS Q ESTA BIEN X FAVOR CHEQUEENLO.\\

		Para la resolución del problema recorrimos el grafo de forma ordenada por niveles. Para esto hicimos una modificación al algoritmo $Breadth\; First\; Search$. La modificación consiste en visitar por niveles hasta que algún vértice no sea accesible (mientras sea nodo accesible se continúa recorriendo su subnivel), al encontrarlo, se lo marca como vértice en "espera" hasta que se encuentre el acceso en algún otro vértice al que está en espera. Si existe el acceso, se accede al vértice en espera y se continúa avanzando. Cabe destacar que este algoritmo puede acceder a cada nodo sólo una vez.\\ 

		El objetivo del $bfs$ es llegar desde el primer vértice al último.\\

		Existe un arreglo de bools llamado $enEspera$ el cual esta seteado en falso si la habitación $i$ tiene puerta, en verdadero en caso contrario. Entonces, para cada vértice, de existir una posible restriccion de acceso, su posición permanece en falso.\\
		
		El siguiente pseudocódigo refleja el comportamiento previamente descripto:\\

		\begin{pseudo}
		\func {prision}{$conexiones, tengo\_llave, puertas, n$}
		\tab $llegue \leftarrow false$\\
		\tab $cola\; q$\\
		\tab $visitados[0..n] \leftarrow false$\\ 
		\tab $enEspera[0..n] \leftarrow false$\\ 
		\tab $encolar(q,0)$\\
		\tab $visitados[0] \leftarrow true$\\
		\tab \WHILE $!esVacia(q) \AND !llegue$\\
		\tab \tab $actual \leftarrow primero(q)$\\
		\tab \tab $desencolar(q)$\\
		\tab \tab \FOR $ i\leftarrow0 \TO n \AND !llegue$\\
		\tab \tab \tab \IF	$conexiones[actual][i] \AND tengo_llave[i] \AND!visitados[i]$\\
		\tab \tab \tab \tab	$tengo_llave[puertas[i]] \leftarrow true$\\
		\tab \tab \tab \tab	$encolar(q,i)$\\
		\tab \tab \tab \tab	$visitados[i] \leftarrow true$\\
		\tab \tab \tab \tab	$llegue \leftarrow (i == n-1)$\\
		\tab \tab \tab \tab \IF	$enEspera[puertas[i]]$\\
		\tab \tab \tab \tab \tab $encolar(q,puertas[i])$\\
		\tab \tab \tab \tab \tab $visitados[puertas[i]] \leftarrow true$\\
		\tab \tab \tab \tab \tab $llegue \leftarrow (n-1==puertas[i])$\\
		\tab \tab \tab \ELSE \\
		\tab \tab \tab \tab \IF $todavia\_no\_tengo\_llave(i)$\\
		\tab \tab \tab \tab \tab $enEspera[i] \leftarrow true$\\
		\tab \RET $llegue$\\
		\end{pseudo}

		En pocas palabras, la idea del algoritmo es buscar con $bfs$ todos los caminos posibles, intentando llegar a el vértice $n$, si se encuentra con un vértice que no es accesible, espera hasta que desde otra rama se habilite ese vértice para poder continuar por ese hilo, mientras al mismo tiempo continúa por todo camino que se encuentre habilitado.\\

		El resultado final viene dado de la variable $llegue$. Es inicializada en falso y se setea en verdadero si sólo si en algún momento $i == n-1$. Si esto ocurre, podemos concluir que pudimos llegar al vértice objetivo (desde la habitación $1$ de salida, llego a la $n$, por lo tanto Bernardo se escapó de la prisión). Si pasa por todos los nodos habilitados y los que pudo habilitar y no puede llegar al vértice $n$, saldrá del ciclo (\textbf{while}) si poder cambiar el valor de $llegue$ y devolverá falso.\\
		
	\end{subsection}


	\begin{subsection}{Análisis de complejidad}
		Como mencionamos previamente, el algoritmo \textbf{no} podrá pasar más de una vez por cada vértice. Mientras quede algun vértice por ver y pueda accederse, seguirá intentando llegar al nodo $n$. Analizando la complejidad, vemos que si pudiera acceder a todos los vértices del grafo, tendría un costo de $n$ iteraciones.\\
		Dentro del ciclo principal tenemos las primeras dos operaciones con costo constante (una asignación y quitar de la pila el primer elemento), y un ciclo anidado ($for$).\\
		EXPLICAR BIEN EN DETALLE EL COSTO DEL IF  DENTRO DEL FORWOWOWOWO
		
		
		El \textbf{while} se ejecuta a lo sumo $n$ veces
		
	\end{subsection}


	\begin{subsection}{Pruebas y Resultados}

	\end{subsection}

\end{section}

