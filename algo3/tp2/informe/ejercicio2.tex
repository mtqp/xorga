\begin{section}{Problema 2}

	\textit{El gobierno planea construir una ciudad. Lo único que falta es asignarle el sentido de circulación a las calles (puede asignarse sólo un sentido a cada una). Toda calle esta conectada a dos esquinas, y se quieren poder determinar si se puede llegar de cualquier esquina a cualquier otra.}
		
	\begin{subsection}{Explicación}
	Para obtener el resultado para el problema, se toma una esquina y se intenta volver a la misma recorriendo otras esquinas, transitando las calles de la posible ciudad. Si no podemos volver a la esquina de la que partimos, podemos concluir que el resultado del problema será: {\em ``No existe forma de asignar el sentido de circulación a las calles para poder llegar de cualquier esquina a cualquier otra'' }. Si podemos volver a la esquina desde la que partimos, podemos afirmar que todas las esquinas que forman parte del circuito, son esquinas accesibles de cualquier otra esquina de ese mismo circuito. Resta ver entonces, que para el resto de las esquinas que no forman parte de ese circuito, se puede partir de alguna de las pertenecientes al circuito y volver, transitando por alguna o todas de las esquinas que no pertenecían al circuito. 
	
	Este proceso se debe realizar para todas las esquinas, agrandando en cada paso el conjunto de esquinas que forman parte del circuito (siempre y cuando no podamos afirmar que \textbf{no} existe solución previamente). Si esto ocurre, la solución al problema será: {\em ``Existe forma de asignar el sentido de circulación a las calles para poder llegar de cualquier esquina a cualquier otra''. }
		
	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		Modelamos este problema mediante grafos donde los vértices corresponden a esquinas y las aristas a las calles que conectan dos esquinas.	

		Generamos la matriz de adyacencia del grafo, de $n\times n$ donde $n$ es la cantidad de esquinas. Cada posición $(i,j)$ de la matriz contiene un $uno$ si la esquina $i$ está conectada con la esquina $j$ por medio de una calle, y $cero$ en caso contrario. Nos referiremos a la matriz como $conexiones$.


		Para la resolución del problema recorrimos el grafo con una modificación del algoritmo $Depth\; First\; Search$. Nuestro algoritmo, en primera instancia, busca el primer ciclo que pueda encontrar. Si no llega a la solución y recorre todo los nodos del grafo, puede afirmar que el resultado es falso, ya que el grafo \textbf{no} es fuertemente conexo. En caso contrario, marca todos los nodos que componen el circuito simple como parte de los nodos que ya se encuentran conectados y entra a un ciclo ($while$). Este último, se encarga de buscar alguna arista que lleve a algún nodo todavía no perteneciente a la solución parcial. Si la encuentra, aplica $dfs$ hasta que vuelva al ciclo, si no la encuentra y todavía quedan nodos por recorrer, no hay solución (devuelve $falso$). El $dfs$ (en caso de que exista una arista libre) busca volver al ciclo original, y si lo hace, agrega todos los nodos por los que pasó como parte del ciclo. Vuelve a empezar hasta que haya pasado por todos los nodos ($devuelve\; fuertemente\; conexo$) o algún nodo no puede volver al ciclo ($devuelve\; no$). Cabe destacar que por cada vez que el $dfs$ encuentre un camino que sale y vuelve del ciclo, el nuevo ciclo crece (se agregan todos los nodos del camino resultante).\VSP

		El siguiente pseudocódigo detalla lo explicado anteriormente.

		\begin{pseudo}
		\func{ciudad}{$conexiones$}
		\tab $ciclo[0...n] \leftarrow false$\\
		\tab $encontre\_ciclo \leftarrow dfs\_primer\_ciclo(conexiones,ciclo)$\\
		\tab \FOR $j$ \TO $n$\\
		\tab \tab $termine \leftarrow termine$ \AND $ciclo[j]$\\
		\tab \WHILE $!termine$ \AND $encontre\_ciclo$\\
		\tab \tab $nodo\_busqueda,\;nodo\_salida \leftarrow adyacente\_extreno(conexiones,ciclo)$\\
		\tab \tab $conexiones[nodo\_busqueda][nodo\_salida] \leftarrow 0$\\
		\tab \tab $encontre\_ciclo \leftarrow dfs\_ciclo(conexiones,nodo\_busqueda,ciclo)$\\
		\tab \tab $conexiones[nodo\_busqueda][nodo\_salida] \leftarrow 1$\\
		\tab \tab $termine \leftarrow true$\\
		\tab \tab \FOR $i$ \TO $n$\\
		\tab \tab \tab $termine \leftarrow termine$ \AND $ciclo[i]$\\
		\tab \RET $termine$\\
		\end{pseudo}

		\begin{itemize}
			\item Tenemos la variable de tipo $bool$ \textbf{termine}, que nos indica si todos los vértices del grafo ya son considerados parte del ciclo. Esta variable se setea, cada vez que encontramos un ciclo (ya sea el primero, o cuando se agregan vértices al principal).

			\item \textbf{dfs\_primer\_ciclo:} La modificación que le hicimos al $dfs$ en este caso consiste en numerar los vértices. Esto nos permite determinar los vértices pertenecientes al circuito una vez que lo detectamos. Para encontrar el primer circuito, cada vez que se sacamos un vértice $i$ de la pila le asignamos el número de su predecesor más $uno$ y verificamos que cada vértice tenga algún adyacente todavía no numerado (podría ser que ya esté visitado), ya que si esto no ocurre sabemos que no existe tal ciclo porque lo que tenemos hasta ahí es un camino y no hay forma de volver (tiene conexión sólo con su predecesor). Si en algún momento un vértice adyacente a $i$ ya fue visitado y su número es menor al de $i$ menos $uno$ (es decir, el adyacente ya visitado no es su predecesor) decimos que hay un ciclo y este está formado por los vértices que tienen menor numeración que $i$ los cuales son marcados en el arreglo $ciclo$. Además, esta función devuelve un $bool$ que nos dice si encontró un circuito ($encontre\_ciclo$). Si $encontre\_ciclo$ es falso significa que no existen circuitos en el grafo por lo que ya podemos afirmar que no es fuertemente conexo.

			\item \textbf{adyacente\_externo:} Esta función se encarga de buscar un vértice que todavía no pertenezca al circuito tal que sea adyacente a uno perteneciente. Seteando la variable $nodo\_busqueda$ con el vértice no perteneciente al circuito principal y $nodo\_salida$ con el vértice que si lo es.
		
			\item \textbf{dfs\_ciclo:} En este caso también numeramos los vértices para determinar cuáles son los pertenecientes al circuito, si es que se puede volver al circuito principal sin usar la arista que conecta el vértice $nodo\_busqueda$ con $nodo\_salida$. Garantizamos que no use esa arista para volver, marcándola como $0$ en la matriz de adyancencia previo ingreso a $dfs\_ciclo$. El valor original de la arista en la matriz de adyacencia es restaurado una vez que la función termina.
			
			La función apila el $nodo\_busqueda$. Apila sus adyacentes (si es que tiene alguno distinto al $nodo\_salida$) y continúa con el algoritmo $dfs$. Termina si: encuentra un vértice adyacente que no esta visitado por el $dfs\_ciclo$ y forma parte del circuito principal, o si la pila se vacía y todavía no logro volver al circuito.
		\end{itemize}
	\end{subsection}


	\begin{subsection}{Análisis de complejidad}
		Al inicio el algoritmo tiene un ciclo $for$ para inicializar el arreglo $ciclo$ (de tamaño $n$) el cual tiene un costo de $n$.
		
		La función $dfs\_primer\_ciclo$ tiene un costo de $n^2$ ya que a lo sumo visita una vez cada vértice recorriendo para cada uno de estos la columna correspondiente en la matriz de adyacencia.
	
		Luego de setear la variable $encontre\_ciclo$ con el resultado de la función $dfs\_primer\_ciclo$ el algoritmo verifica si todos los vértices ya pertenecen a un circuito, esto lo hace con un ciclo $for$ el cual recorre todo el arreglo $ciclo$ de tamaño $n$. Por lo que el costo de este ciclo es $n$.

		Dentro el algoritmo $ciudad$ tenemos un ciclo $while$ que itera a lo sumo $n-3$ veces (encuentra el ciclo principal de tres vértices y dentro del ciclo el $dfs_ciclo$ agrega un vértice por iteración). Dentro de este ciclo, hay dos llamadas a funciones ($adyacente\_externo$ y $dfs\_ciclo$), un ciclo $for$ de $uno$ hasta $n$ (con costo lineal),y una cantidad constante de asignaciones, comparaciones e indexación con costo constante. Entonces el costo del $while$ resulta ser el máximo entre los costos mencionados y el costo de las funciones por $n$ (ya que es el orden de la cantidad de iteraciones del while).
				
		\begin{itemize}
		\item La función $adyacente\_externo$ tiene un costo del orden de $n^2$ porque recorre todos los vértices y para cada uno de estos que pertenece al circuito busca entre todos los vértices alguno que sea adyacente a él y no pertenezca al circuito (no termina apenas encuentre uno, sino que los recorre todos y se queda con el último que cumple la condición).

		\item Por otro lado, la función $dfs\_ciclo$ posee la misma complejidad que $dfs\_primer\_ciclo$. Dado un vértice, a lo sumo visitará todo los demás menos los que ya pertenecen al circuito principal (a lo sumo serán $n-3$ vértices). Para cada uno de estos, deberá obtener sus adyacentes, los que pueden ser $n$.
		\end{itemize}

		Podemos decir entonces que el ciclo del algoritmo $ciudad$ tiene costo del orden de $n^3$.

		La complejidad del algoritmo $ciudad$ viene dada por el máximo entre el costo del ciclo ($while$), dos ciclos $for$ (iteran de $uno$ hasta $n$ con operaciones de costo constante dentro)y la llamada a al función $dfs\_primer\_ciclo$. Por lo tanto podemos afirmar que la complejidad asintóntica es \Ode{n^3}.
	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
	
		Para probar correctitud contamos con un generador de instancias FUERTEMENTE CONEXO Y OTRO QUE DEVUELVEN LO CONTRARIO QUE ESTA EN LA CASA DE MARIAN, NO SABEMOS COMO GUARDA EL TEST.IN Y BLAH. De esta forma, con una comparación de archivos (comando \texttt{make diffs} en la carpeta Ej2 QUE DANI VA A SER RE JEDI) podemos saber para cada instancia si el resultado obtenido por nuestro algoritmo es correcto.

		Para contar la cantidad de operaciones realizadas por el algoritmo tenemos un generador de instancias aleatorias, mejor y peor caso. La cantidad de esquinas varía de $0$ a $100$, siendo $una$ la cantidad de instancias para cada $n$ (cabe aclarar que es una instancia aleatoria, una mejor, y una peor).

		A continuación se muestra para cada instancia la cantidad de operaciones en función de la cantidad esquinas. Esperamos ver como la función $c*n^3$ acota superiormente nuestro peor caso (con $c=5.8$), y como el mejor acota inferiormente (menor igual) a cualquiera, ya sea aleatoria o peor caso a partir de cierto $n$.

	\gra{ciudad/count_completos.pdf}

		En el gráfico anterior podemos ver que la complejidad analizada de forma teórica se condice con las instancias generadas. De todas formas no podemos afirmar que el mejor caso es lineal ya que puede estarse tratando de costo constante. Creemos que la escala del eje $y$, es decir la gran cantidad de valores que puede admitir en un gráfico de ese tamaño, es la que nos da una impresión errónea.

		Por lo tanto, el siguiente gráfico mostrará las mismas instancias, pero con un rango de valores del eje $y$ mucho menor. Esperamos ver que en realidad el mejor caso es una recta, y que tanto los casos aleatorios como el peor, se mantienen o igual, o por encima de ella.

	\gra{ciudad/count_test_mejor_caso.pdf}

		Podemos afirmar que el mejor caso se comporta como tal, y tiene costo lineal. Además, verificamos que nuestra hipótesis sobre el comportamiento observado en el primer gráfico es correcta (la escala no era la adecuada).

	\end{subsection}

	\begin{subsection}{Conclusiones}
		El modelado del problema mediante un grafo, nos facilitó la resolución del problema. Dejamos de pensar si podíamos asignar direcciones a las calles de una ciudad de manera tal de poder ir de una esquina a cualquiera, y nos dedicamos a verificar si se cumplía una propiedad en el grafo (esta propiedad es la de ser fuertemente conexo).

		La implementación de nuestro algoritmo resultó ser polinomial, gracias a las técnicas conocidas aplicadas a grafos, pudimos mediante un $dfs$ con ligeras modificaciones (las que mantuvieron las bases del algoritmo original), obtener un resultado correcto. 

		Nos resultó el problema más complicado de resolver, ya que en un principio todas nuestras posibles soluciones no resolvían el problema en todas las instancias posibles y/o no cumplían con la complejidad. La solución final necesito de un crecimiento por parte nuestra, en la forma de ver el problema. Primeramente queríamos buscar ciclos y tratar de unirlos entre sí hasta abarcar todos los vértices. Logramos resolverlo cuando observamos que nuestra primer idea, era lo mismo que tener un ciclo principal e intentar buscar ciclos conectados a él, ignorando si en el proceso, nos encontrabamos con un ciclo aislado. Aún así, nuestra primer implementación correcta mostraba que necesitabamos todavía refinar el algoritmo. Esta solución fue posible, aplicando la técnica $top\-down$.

		Computacionalmente es un problema 'bien' resuelto, dado que la complejidad resultó ser \Ode{n^3}.
	\end{subsection}
\end{section}

