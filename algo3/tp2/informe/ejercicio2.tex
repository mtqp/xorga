\begin{section}{Problema 2}

	\textit{El gobierno planea construir una ciudad. Lo único que falta es asignarle el sentido de circulación a las calles (puede asignarse sólo un sentido a cada una). Toda calle esta conectada a dos esquinas, y se quieren poder determinar si se puede llegar de cualquier esquina a cualquier otra.}
		
	\begin{subsection}{Explicación}
	Para obtener el resultado para el problema, se toma una esquina y se intenta volver a la misma recorriendo otras esquinas, transitando las calles de la posible ciudad. Si no podemos volver a la esquina de la que partimos, podemos concluir que el resultado del problema será: {\em ``No existe forma de asignar el sentido de circulación a las calles para poder llegar de cualquier esquina a cualquier otra'' }. Si podemos volver a la esquina desde la que partimos, podemos afirmar que todas las esquinas que forman parte del circuito, son esquinas accesibles de cualquier otra esquina de ese mismo circuito. Resta ver entonces, que para el resto de las esquinas que no forman parte de ese circuito, se puede partir de alguna de las pertenecientes al circuito y volver, transitando por alguna o todas de las esquinas que no pertenecían al circuito. 
	
	Este proceso se debe realizar para todas las esquinas, agrandando en cada paso el conjunto de esquinas que forman parte del circuito (siempre y cuando no podamos afirmar que \textbf{no} existe solución previamente). Si esto ocurre, la solución al problema será: {\em ``Existe forma de asignar el sentido de circulación a las calles para poder llegar de cualquier esquina a cualquier otra''. }
		
	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		Modelamos este problema mediante grafos donde los vértices corresponden a esquinas y las aristas a las calles que conectan dos esquinas.	

		Generamos la matriz de adyacencia del grafo, de $n\times n$ donde $n$ es la cantidad de esquinas. Cada posición $(i,j)$ de la matriz contiene un $uno$ si la esquina $i$ está conectada con la esquina $j$ por medio de una calle, y $cero$ en caso contrario. Nos referiremos a la matriz como $conexiones$.


		Para la resolución del problema recorrimos el grafo con una modificación del algoritmo $Depth\; First\; Search$. Nuestro algoritmo, en primera instancia, busca el primer ciclo que pueda encontrar. Si no llega a la solución y recorre todo los nodos del grafo, puede afirmar que el resultado es falso, ya que el grafo \textbf{no} es fuertemente conexo. En caso contrario, marca todos los nodos que componen el circuito simple como parte de los nodos que ya se encuentran conectados y entra a un ciclo ($while$). Este último, se encarga de buscar alguna arista que lleve a algún nodo todavía no perteneciente a la solución parcial. Si la encuentra, aplica $dfs$ hasta que vuelva al ciclo, si no la encuentra y todavía quedan nodos por recorrer, no hay solución (devuelve $falso$). El $dfs$ (en caso de que exista una arista libre) busca volver al ciclo original, y si lo hace, agrega todos los nodos por los que pasó como parte del ciclo. Vuelve a empezar hasta que haya pasado por todos los nodos ($devuelve\; fuertemente\; conexo$) o algún nodo no puede volver al ciclo ($devuelve\; no$). Cabe destacar que por cada vez que el $dfs$ encuentre un camino que sale y vuelve del ciclo, el nuevo ciclo crece (se agregan todos los nodos del camino resultante).\VSP

		El siguiente pseudocódigo detalla lo explicado anteriormente.

		\begin{pseudo}
		\func{ciudad}{$conexiones$}
		\tab $ciclo[0...n] \leftarrow false$\\
		\tab $encontre\_ciclo \leftarrow dfs\_primer\_ciclo(conexiones,ciclo)$\\
		\tab \FOR $j$ \TO $n$\\
		\tab \tab $termine \leftarrow termine$ \AND $ciclo[j]$\\
		\tab \WHILE $!termine$ \AND $encontre\_ciclo$\\
		\tab \tab $nodo\_busqueda,\;nodo\_salida \leftarrow adyacente\_extreno(conexiones,ciclo)$\\
		\tab \tab $conexiones[nodo\_busqueda][nodo\_salida] \leftarrow 0$\\
		\tab \tab $encontre\_ciclo \leftarrow dfs\_ciclo(conexiones,nodo\_busqueda,ciclo)$\\
		\tab \tab $conexiones[nodo\_busqueda][nodo\_salida] \leftarrow 1$\\
		\tab \tab $termine \leftarrow true$\\
		\tab \tab \FOR $i$ \TO $n$\\
		\tab \tab \tab $termine \leftarrow termine$ \AND $ciclo[i]$\\
		\tab \RET $termine$\\
		\end{pseudo}

		\begin{itemize}
			\item Tenemos la variable de tipo $bool$ \textbf{termine}, que nos indica si todos los vértices del grafo ya son considerados parte del ciclo. Esta variable se setea, cada vez que encontramos un ciclo (ya sea el primero, o cuando se agregan vértices al principal).

			\item \textbf{dfs\_primer\_ciclo:} La modificación que le hicimos al $dfs$ en este caso consiste en numerar los vértices. Esto nos permite determinar los vértices pertenecientes al circuito una vez que lo detectamos. Para encontrar el primer circuito, cada vez que se sacamos un vértice $i$ de la pila le asignamos el número de su predecesor más $uno$ y verificamos que cada vértice tenga algún adyacente todavía no numerado (podría ser que ya esté visitado), ya que si esto no ocurre sabemos que no existe tal ciclo porque lo que tenemos hasta ahí es un camino y no hay forma de volver (tiene conexión sólo con su predecesor). Si en algún momento un vértice adyacente a $i$ ya fue visitado y su número es menor al de $i$ menos $uno$ (es decir, el adyacente ya visitado no es su predecesor) decimos que hay un ciclo y este está formado por los vértices que tienen menor numeración que $i$ los cuales son marcados en el arreglo $ciclo$. Además, esta función devuelve un $bool$ que nos dice si encontró un circuito ($encontre\_ciclo$). Si $encontre\_ciclo$ es falso significa que no existen circuitos en el grafo por lo que ya podemos afirmar que no es fuertemente conexo.

			\item \textbf{adyacente\_externo:} Esta función se encarga de buscar un vértice que todavía no pertenezca al circuito tal que sea adyacente a uno perteneciente. Seteando la variable $nodo\_busqueda$ con el vértice no perteneciente al circuito principal y $nodo\_salida$ con el vértice perteneciente.
		\end{itemize}
		

	\end{subsection}


	\begin{subsection}{Análisis de complejidad}
		
	\end{subsection}


	\begin{subsection}{Pruebas y Resultados}

	\end{subsection}

\end{section}

