extern apply_mask

%macro convencion_C 1
	push ebp
	mov ebp,esp
	sub esp,%1
	push edi
	push esi
	push ebx
%endmacro

%macro convencion_C_fin 1
	pop ebx
	pop esi
	pop edi
	add esp,%1
	pop ebp
	ret
%endmacro

%macro getLineSize 2	; getLineSize(width, align)
	mov eax, %1			;eax = width
	mov esi, %2			;esi = 4
	xor edx, edx		;edx = 0		[INSTRUCCION NECESARIA?]
	div esi				;eax = width/align , edx = width%align

	mov eax, %1			;eax = width	[no necesito la división]
	cmp edx, 0			;el ancho era múltiplo de 4?
	je  .return			;si ya era, entonces devuelve el line

	sub eax, edx		;eax = width - width%align
	add eax, esi		;eax = width - witdh%align + align
.return:
	mov line, eax
%endmacro

%macro eax_to_char_sat 0
	cmp eax,255
	jle .saturMin
	mov al,255
.saturMin:
	cmp eax,0
	jge .return
	mov al, 0
.return:
%endmacro

section .data

	sobelX: db -1,0,1,-2,0,2,-1,0,1
	sobelY: db -1,-2,-1,0,0,0,1,2,1

section .text

	global asmSobel

asmSobel:
	convencion_C 8

	%define line		[ebp-4]
	;%define yindex		[ebp-8]
	%define align		4
	%define mask_size	3
	%define ptr_src		[ebp+8]
	%define ptr_dst		[ebp+12]
	%define width		[ebp+16]
	%define height		[ebp+20]
	%define xorder		[ebp+24]
	%define yorder		[ebp+28]

	getLineSize	width, align	; calcula el ancho de la línea en memoria
	;xor dword yindex, yindex

; [*] establezco los límites de procesamiento respecto al pixel de src
	sub dword width, mask_size	; width -= mask_size
	sub dword height,mask_size	; height -= mask_size

	mov edi, 0					; edi = 0 [contador de columnas]
	mov esi, 0					; esi = 0 [contador de filas]
	mov ebx, ptr_src			; puntero al inicio de línea

;posición de src = esi*line+edi = ebx+edi
;posición de dst = esi*(line+1)+edi+1 = ebx+line+edi+1

ciclo:
	lea ecx, [ebx+edi]			; ecx = line [para poder hacer cuentas]

	push mask_size				; 4to parámetro: tamaño de la máscara
	push sobelX					; 3er paráemtro: máscara
	push dword line				; 2do parámetro: tamaño de la línea
	push dword ecx				; 1er parámetro: posición en src (top-left)
	call apply_mask
	add esp, 16					; vuelvo el stack a donde estaba originalmente

	lea ecx, [ebx+edi]			; ecx = posición en src
	sub ecx, ptr_src
	add ecx, ptr_dst
	add ecx, line				; ecx = posición en src + (0,1)
	inc ecx						; ecx = posición en src + (1,1)

	eax_to_char_sat
	mov byte [ecx],	al			; pone el resultado de apply_mask en dst

	inc edi						; aumenta la columna en src
	cmp edi, width				; compara la posición en X con el ancho de la img
	jne ciclo					; repite hasta terminar la columna

	inc esi						; pasa a la siguiente fila
	add ebx, line				; corre el puntero a la fila siguiente
	xor edi, edi				; pone la columna en 0
	cmp esi, height				; compara la posición en Y con la altura de la img
	jne ciclo					; repite todo el ciclo hasta llegar a la última fila

	convencion_C_fin 8
