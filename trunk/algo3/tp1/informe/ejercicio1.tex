\begin{section}{Problema 1}

	\textit{Dados $b,n \in \mathbb{N} $ calcular $b^n\; mod\; n$}

	\begin{subsection}{Explicación}

		Una solución factible al problema es utilizar un algoritmo recursivo basado en la técnica $Divide \& Conquer$.
		La idea sería quedarnos cada vez con un problema más chico, dividiendo el exponente a la mitad y resolver recursivamente dicho problema hasta llegar a uno suficientemente chico (en este caso $n==2$) para luego combinar las soluciones elevando al cuadrado lo ya calculado y obtener así una solución al problema original. En el caso donde $n$ fuese impar se resuelve el problema para $n-1$ a través del procedimiento mencionado y luego se multiplica el resultado por $b$.

		Para la resolución del problema decidimos utilizar un algoritmo iterativo frente a uno recursivo debido al uso que este último hace de la pila, lo cual implica repetidos accesos a memoria que disminuyen la performance del algoritmo, y la posibilidad de {\em stack overflow}.

		La versión iterativa de la solución funciona de la siguiente manera: en cada iteración el algoritmo divide el exponente a la mitad y eleva al cuadrado el acumulador (en la primer iteración $b$). Cuando llega a un exponente impar multiplica el resultado por el acumulador y continua elevando dicho acumulador. Cuando el exponente llega a uno repite lo anterior y termina. Es decir, el resultado es la productoria de los resultados parciales obtenidos en los exponentes impares.

		Al tener un acumulador que nos guarda las potencias ya calculadas el algoritmo evita hacer calculos repetidos y logra minimizar la cantidad de multiplicaciones.

		Tanto la versión recursiva como la iterativa toman módulo $n$ luego de cada multiplicación para asegurarse que el resultado entra en el tamaño de la variable (suponiendo que $(n-1)\times (n-1)$ entra).


		\begin{subsubsection}{Análisis de complejidad}
		Esta vez, elegimos un modelo logaritmico para analizar el algoritmo, ya que las operaciones que aplicamos, en teoría, dependen del logaritmo del número en cuestión, o dicho de otra forma, del tamaño de la entrada. No obstante, en los resultados muchas de ellas tienen costo uniforme por trabajar con números de tamaño acotado (\texttt{unsigned long long int}) para simplificar la implementación.\Pa

		Sea $m = n$ \\

		\begin{pseudo}
			\WHILE{$m>0$} & \tOde{\log^3 n} \\
			\tab \IF{ $m$ es impar } & \tOde{\log m} \\
			\tab \tab $tmp \leftarrow tmp * b$ & \tOde{\log^{2}n} \\
			\tab \tab $tmp \leftarrow tmp\; mod\; n$ & \tOde{\log^{2}n} \\
			\tab $m \leftarrow \frac{m}{2}$ & \tOde{\log m} \\
			\tab $b \leftarrow b^2$ & \tOde{\log^{2} n} \\
			\tab $b \leftarrow b\; mod \; n$ & \tOde{\log^{2} n} \\
			\RET $tmp$
		\end{pseudo}
		
		\noindent\textbf{Cantidad de operaciones}\\

		\begin{center}
		\begin{tabular}{rlcl}
			1er&iteración & $\rightarrow$ & $m = n$ \\
			2da&iteración & $\rightarrow$ & $m = \frac{n}{2}$ \\
			3er&iteración & $\rightarrow$ & $m = \frac{n}{2^2}$ \\
			4ta&iteración & $\rightarrow$ & $m = \frac{n}{2^3}$ \\
			&\vdots&&\vdots \\
			$k$-ésima&iteración & $\rightarrow$ & $m = \frac{n}{2^{k-1}} = 1$  
		\end{tabular}
		\end{center}

		\noindent Como el algoritmo termina cuando $m=1$ tenemos, \\
		\begin{eqnarray*}
			\frac{n}{2^{k-1}}&=& 1 \\
			n &=& 2^{k-1} \\
			\log n &=& \log\; 2^{k-1} \\
			\log n &=& k-1 \Rightarrow k = \log( n )+1
		\end{eqnarray*}

		\noindent es decir, el algoritmo hace $\log(n)+1$ iteraciones, cada una con una cantidad constante de operaciones.

		Por lo tanto, la cantidad de operaciones que hace el algoritmo es del orden de $\log n$ y \Ode{\log n} $\subset$ \Ode{n}.

		\vspace{0.5cm}
		\noindent\textbf{Complejidad en el modelo logarítimico}\\

Como $m\leq n$ y la función logaritmo es estrictamente creciente, $\log m \leq \log n$. De la misma manera, $\log b$ y $\log tmp$ están acotados por $\log n$. Por lo tanto, la complejidad en el modelo logarítmico es: \\
\Ode{\log(n)*(\log(n)+\log^2(n)+\log^2(n)+\log(n)+\log^2(n)+\log^2(n))} $=$ \\
$=$ \Ode{\log(n)*(2\log(n)+4\log^2(n))} $=$ \Ode{2\log^2 n + 4\log^3 n} \\

Luego, por definición, 
			\begin{center}
				\Ode{2\log^2 n + 4\log^3 n} $=$ \Ode{max(2\log^2 n , 4\log^3 n)} $=$ \Ode{\log^3 n}.
			\end{center}

			%La complejidad del algoritmo en el modelo logarítmico es: \\
%(1) \Ode{\log(n) * (\log(m)*\log(2)+\log(tmp)*\log(b)+\log(tmp)*\log(n)+\log(m)*\log(2)+\log^2(b)+\log(b)*\log(n))}

%			Como $m\leq n$ y la función logaritmo es estrictamente creciente, $\log m \leq \log n$. De la misma manera $\log b$ y $\log tmp$ están acotados por $\log n$. Por lo tanto,

%(1) $\leq$ \Ode{\log(n)*(\log(n)+\log^2(n)+\log^2(n)+\log(n)+\log^2(n)+\log^2(n))} $=$ \Ode{\log(n)*(2\log(n)+4\log^2(n))} $=$ \Ode{2\log^2 n + 4\log^3 n}

%		Por definición, \Ode{2\log^2 n + 4\log^3 n} $=$ \Ode{max(2\log^2 n , 4\log^3 n)} $=$ \Ode{\log^3 n}.
		Entonces, la complejidad del algoritmo resulta ser: \Ode{log^3 n}\VSP
		
		\noindent\textbf{En función del tamaño de la entrada}\\

			El tamaño de la entrada $t$ es $\log n$ ya que $b$ es acotado ($n=2^t$). Entonces la complejidad del algoritmo en función del tamaño de entrada es: \Ode{\log^3 2^t}=\Ode{t^3}. El algoritmo es logarítmico.

		\end{subsubsection}
	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		La siguiente tabla representa la correspondencia entre las variables de entrada ($b$ y $n$) en cada iteración del algoritmo implementado:

		\vspace{0.5cm}
		\begin{center}
		\begin{tabular}{|l|c|c|c|c|c|}
			\hline
			iteración   & $1$ & $2$           & $3$             & ... & $k$ \\
			\hline
			$n$         & $n$ & $\frac{n}{2}$ & $\frac{n}{2^2}$ & ... & $\frac{n}{2^{k-1}}$ \\
			\hline
			$b$         & $b$ & $b^2$         & $b^4$           & ... & $b^{2^{k-1}}$ \\
			\hline
		\end{tabular}
		\end{center}

		\vspace{0.5cm}
		\noindent Sean \\
		\indent
		\begin{tabular}{lp{6cm}}
			$A_k = \frac{n}{2^{k-1}}$ & la sucesión con los valores de $n$ en la iteración $k$, y \\
			$Z_k = impar(A_k) * b^{2^{k-1}} + par( A_k )$ $^{[2]}$ & la sucesión que tiene los valores de $b$ corres\-pondientes a los $n$ impares y $1$ en los pares
		\end{tabular} \\
		\vspace{0.2cm}
		entonces el cálculo hecho por el algoritmo está dado por 
		$$\displaystyle\prod_{i=1}^k Z_i = b^n$$

\noindent Además, luego de cada multiplicación toma el módulo ya que
 $$b^k * b^{n-k}\; mod\;n = (b^k\;mod\;n)*(b^{n-k}\;mod\;n)\;\forall\;k\leq n ^{[1]}$$

De esta manera, incluso si el cálculo de $b^n$ es un número tan grande que no entra en el tamaño de la variable, se va a poder realizar sin problemas (suponiendo que $(n-1)^2$ entra en una variable).

\vspace{0.5cm}
\noindent{\footnotesize [1] $par(x)=1-impar(x)$\\ $impar$ se define como:
\begin{displaymath}
	impar(x)=\left\{
	\begin{array}{ll}
		1 & $si $x$ es impar$ \\
		0 & $sino$
	\end{array}\right.
\end{displaymath}
} \\
{\footnotesize [2] Por propiedades del módulo $x*y\; mod \; z = (x\; mod\; z)*(y\; mod\; z)$ } \\


	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
		Para probar correctitud tenemos un generador de instancias random que nos devuelve dos archivos, en uno \texttt{test.in} la instancia elegida ($b$ $n$) y otro \texttt{test.out} el resultado ($b^n \mod n$). De esta forma, con una comparación de archivos (comando $diff\;test.out\;bn\_mod\_n.out$ ) podemos saber para cada instancia si el resultado obtenido por nuestro algoritmo se condice con el resultado correspondiente a esa instancia en el archivo \texttt{test.out}.
		
		Para llevar a cabo las pruebas de este algoritmo en cuanto a operaciones realizadas por instancia, y tiempo en segundos transcurridos, generamos números en forma aleatoria, con $b$ comprendido entre $0$ y $200$, y $n$ entre 1 y $10^7$.\\
		
		\gra{ej1_counts}\VSP
		
		En este gráfico se muestra la función que dada una instancia, nos devuelve la cantidad de operaciones realizadas. Se ve claramente cómo esta acotada por la función logaritmo, con $n$ como parámetro de entrada. Se pueden apreciar algunos casos en el fondo del gráfico que co\-rres\-pon\-den al caso trivial del ejercicio, en los que no hubo necesidad de iterar para llegar al resultado.

		\gra{ej1_time}\VSP

		En este otro gráfico se observa de forma muy parecida a la función que dada una instancia devuelve el tiempo transcurridos durante la ejecución del algoritmo. También se ve acotada por la función logaritmo con parámetro $n$. Como medir el tiempo no es una herramienta muy precisa, se pueden ver algunos {\em outliers} por encima de la curva del logaritmo. Aun así, los resultados coninciden con las predicciones en cuanto a la complejidad.\Pa

		En general, podemos ver que los resultados prácticos se mantienen cada vez más abajo de la complejidad teórica analizada (línea verde) y se corresponden en forma con la misma. Por lo que sería lógico creer que también lo va a hacer para mayores tamaños de entrada que los aquí representados.
		Por esto suponemos que es una buena cota para la complejidad del algoritmo.
	\end{subsection}

\end{section}

