\begin{section}{Problema 1}

	\textit{Dados $b,n \in \mathbb{N} $ calcular $b^n\; mod\; n$}

	\begin{subsection}{Explicación}

		Para la resolución del problema, usamos la técnica de $Divide$ $\&$ $Conquer$ para tratar de minimizar la cantidad
	de multiplicaciones. 

		\begin{subsubsection}{Análisis de complejidad}
		Esta vez, elegimos un modelo logarítmico para analizar el algoritmo, ya que las operaciones que aplicamos, en teoría, dependen del logaritmo del número en cuestión, o dicho de otra forma, del tamaño de la entrada. No obstante, en los resultados muchas de ellas tienen costo uniforme por trabajar con números de tamaño acotado (\texttt{unsigned long long int}) para simplificar la implementación.

		\begin{pseudo}
			Sea $m = n$ \\
			\WHILE{$m>0$} & \tOde{\log_2^3 n} \\
			\tab \IF{ $m$ es impar } & \tOde{\log_2 m} \\
			\tab \tab $tmp \leftarrow tmp * b$ & \tOde{\log_{2}^{2}(n)} \\
			\tab \tab $tmp \leftarrow tmp\; mod\; n$ & \tOde{\log_{2}^{2}(n)} \\
			\tab $m \leftarrow \frac{m}{2}$ & \tOde{\log_2 m} \\
			\tab $b \leftarrow b^2$ & \tOde{\log_{2}^{2} n} \\
			\tab $b \leftarrow b\; mod \; n$ & \tOde{\log_{2}^{2} n} \\
			\RET $tmp$
		\end{pseudo}
			
		\begin{tabular}{l l}
			1 iteración & $m = n$ \\
			2 iteración & $m = \frac{n}{2}$ \\
			3 iteración & $m = \frac{n}{2^2}$ \\
			4 iteración & $m = \frac{n}{2^3}$ \\
			k iteración & $m = \frac{n}{2^{k-1}} = 1$  
		\end{tabular}

		Como el algoritmo termina cuando $m=1$ entonces, \\
			$\frac{n}{2^{k-1}} = 1$ \\
			$n = 2^{k-1}$ \\
			$\log_2 n = \log_2 2^{k-1}$ \\
			$\log_2 n = k-1 \Rightarrow k = \log_2( n )+1 $ \\

		Entonces, el algoritmo hace $\log_2(n)+1$ iteraciones, cada una con una cantidad constante de operaciones. 
		Por lo tanto, la cantidad de operaciones que hace el algoritmo es del orden de $\log_2 n$ y \Ode{\log n} $\subset$ \Ode{n}.

		\vspace{0.5cm}
		\noindent\textbf{Complejidad en el modelo logarítimico}

			La complejidad del algoritmo en el modelo logarítmico es: \\
(1) \Ode{\log_2(n) * (\log(m)*\log(2)+\log(tmp)*\log(b)+\log(tmp)*\log(n)+\log(m)*\log(2)+\log^2(b)+\log(b)*\log(n))}

			Como $m\leq n$ y la función logaritmo es estrictamente creciente, $\log m \leq \log n$. De la misma manera $\log b$ y $\log tmp$ están acotados por $\log n$. Por lo tanto,

(1) $\leq$ \Ode{\log(n)*(\log(n)+\log^2(n)+\log^2(n)+\log(n)+\log^2(n)+\log^2(n))} $=$ \Ode{\log(n)*(2\log(n)+4\log^2(n))} $=$ \Ode{2\log^2 n + 4\log^3 n}

		Por definición, \Ode{2\log^2 n + 4\log^3 n} $=$ \Ode{max(2\log^2 n , 4\log^3 n)} $=$ \Ode{\log^3 n}.

		\end{subsubsection}
	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		La siguiente tabla representa la correspondencia entre las variables de entrada ($b$ y $n$) en cada iteración del algoritmo implementado:

		\vspace{0.5cm}
		\begin{center}
		\begin{tabular}{|l|c|c|c|c|c|}
			\hline
			iteración   & $1$ & $2$           & $3$             & ... & $k$ \\
			\hline
			$n$         & $n$ & $\frac{n}{2}$ & $\frac{n}{2^2}$ & ... & $\frac{n}{2^{k-1}}$ \\
			\hline
			$b$         & $b$ & $b^2$         & $b^4$           & ... & $b^{2^{k-1}}$ \\
			\hline
		\end{tabular}
		\end{center}

		\vspace{0.5cm}
		\noindent Sean \\
		\indent
		\begin{tabular}{ll}
			$A_k = \frac{n}{2^{k-1}}$ & bla bla bla, y \\
			$Z_k = impar(A_k) * b^{2^{k-1}}$ $^{[2]}$ & la sucesión que tiene los valores de $b$ correspondientes a los $n$ impares
		\end{tabular} \\
		\vspace{0.2cm}
		entonces el cálculo hecho por el algoritmo está dado por 
		$$\displaystyle\prod_{i=1}^k Z_i = b^n$$

\noindent Además, luego de cada multiplicación toma el módulo ya que
 $$b^k * b^{n-k}\; mod\;n = (b^k\;mod\;n)*(b^{n-k}\;mod\;n)\;\forall\;k\leq n ^{[1]}$$

De esta manera, incluso si el cálculo de $b^n$ es un número tan grande que no entra en el tamaño de la variable, se va a poder realizar sin problemas (suponiendo que $(n-1)^2$ entra en una variable).




%El algoritmo en cada iteración reduce el exponente a la mitad y a la vez eleva al cuadrado la base. Al dividir el exponente pueden pasar dos casos:
%\begin{itemize}
%	\item \textbf{El nuevo exponente es impar:} se multiplica el resultado calculado hasta el momento ($tmp$) por el $b$ calculado en la iteración anterior.
%	\item \textbf{El nuevo exponente es par:} 
%\end{itemize}

\vspace{0.5cm}
\noindent{\footnotesize [1] impar se define como:
\begin{displaymath}
	impar(x)=\left\{
	\begin{array}{ll}
		1 & $si $x$ es impar$ \\
		0 & $sino$
	\end{array}\right.
\end{displaymath}
} \\
{\footnotesize [2] Por propiedades del módulo $x*y\; mod \; z = (x\; mod\; z)*(y\; mod\; z)$ } \\


	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}

	\end{subsection}

\end{section}

