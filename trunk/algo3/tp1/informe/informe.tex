\documentclass[12pt,titlepage]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{color}
\usepackage{graphicx} % para insertar imagenes


\newcommand{\func}[2]{\texttt{#1}(#2)\\}
\newcommand{\tab}{\hspace*{2em}}
\newcommand{\FOR}{\textbf{for }}
\newcommand{\TO}{\textbf{ to }}
\newcommand{\IF}{\textbf{if }}
\newcommand{\WHILE}{\textbf{while }}
\newcommand{\THEN}{\textbf{then }}
\newcommand{\ELSE}{\textbf{else }}
\newcommand{\RET}{\textbf{return }}
\newcommand{\MOD}{\textbf{ \% }}
\newcommand{\OR}{\textbf{ or }}
\newcommand{\tOde}[1]{\tab \small{O($#1$)}}
\newcommand{\Ode}[1]{O($#1$)}
\newcommand{\Thetade}[1]{{\small$\Theta$($#1$)}}
\newcommand{\Omegade}[1]{{\small$\Omega$($#1$)}}
\newcommand{\VSP}{\vspace*{3em}}
\newcommand{\Pa}{\vspace{5mm}}
\newenvironment{pseudo}{\begin{tabular}{ll}}{\end{tabular}\VSP}

\newcommand{\gra}[1]{\noindent\includegraphics[scale=.60]{#1}\\}

\title{{\sc\normalsize Algoritmos y estructuras de datos III}\\{\bf Trabajo Práctico Nº1}}
\author{\begin{tabular}{lcr}
Carla Livorno & 424/08 & carlalivorno@hotmail.com\\
Daniel Grosso & 694/08 & dgrosso@gmail.com\\
Diego Raffo & 423/08 & enanodr@hotmail.com \\
Mariano De Sousa Bispo & 389/08 & marian\_sabianaa@hotmail.com \\
\end{tabular}}
\date{\VSP \normalsize{Abril 2010}}
%\date{}
\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}
\tableofcontents
\newpage

	\begin{section}*{Introducción}	\addcontentsline{toc}{section}{Introducción}
	Este trabajo tiene como objetivo la aplicación de diferentes técnicas algorítmicas para la resolución de tres problemas particulares, el cálculo de complejidad teórica en el peor caso de cada algoritmo implementado, y la posterior verificación empírica.
	
	El lenguaje utilizado para implementar los algoritmos de todos los problemas fue C/C++
	\end{section}

	\input{ejercicio1.tex}

	\newpage

	\input{ejercicio2.tex}

	\newpage

	\input{ejercicio3.tex}
	
	\newpage
	%\input{anexo.tex}
	
	\newpage
	
	\begin{section}{Compilación y ejecución de los programas}
	Para compilar los programas se puede usar el comando \texttt{make} (Requiere el compilador \texttt{g++}).
	Se pueden correr los programas de cada ejercicio ejecutando \texttt{./bn\_mod\_n}, \texttt{./ronda\_de\_amigas} y \texttt{./programadores} respectivamente.
		
	Los programas leen la entrada de stdin y escriben la respuesta en stdout. 		Para leer la entrada de un archivo \texttt{Tp1EjX.in} y escribir la respuesta en un archivo \texttt{Tp1EjX.out} ses puede usar:\\ \texttt{./(ejecutable) < Tp1EjX.in > Tp1EjX.out}
		
	Para medir los tiempos de ejecución: \texttt{./(ejecutable) time}. Devuelve para cada instancia el tamaño seguido de la cantidad de ciclos de reloj consumidos.

	Para contar la cantidad de operaciones: \texttt{./(ejecutable) count}. Devuelve para cada instancia el tamaño seguido de la cantidad de operaciones de cada instancia.
	\end{section}
	
	\begin{section}{Conclusiones}
		Pudimos implementar las soluciones a los problemas propuestos utilizando diversas técnicas algorítmicas. En todos los casos las mediciones de tiempo y cantidad de operaciones se correspondieron con las complejidades teóricas calculadas. Esto indica que los modelos elegidos fueron adecuados.

		En el problema $dos$ nos encontramos con un algoritmo de complejidad exponencial que a partir de cierto tamaño de entrada 'relativamente chico' se torna inutil, ya que la ejecución para dichas instancias es extremadamente lenta y en la practica muchas veces esto no es aceptable. Esto significa que el problema no esta 'bien' resuelto para tamaños de entrada no necesariamente grandes.
	\end{section}

\end{document}
