\begin{section}{Problema 2}
	\textit{Se tiene $n$ chicas cada de estas tiene $k$ amigas, con $k<n$. Decidir si se puede formar una ronda que las contega a todas donde cada una de las chicas este de la mano de dos de sus amigas.}
	\begin{subsection}{Explicación}
		El Algoritmo busca todas las formas de armar la ronda utilizando la técnica de backtracking. Para esto, el algoritmo recorre la matriz de relaciones uniendo a las chicas hasta que:
		\begin{itemize} \item forma la ronda (encuentra una combinación posible), o \item no puede armar la ronda de esa forma, y\end{itemize}
		
				saca la última chica que puso y vuelve a intentar formar la ronda poniendo otra amiga. Termina cuando encuentra una forma de armar la ronda o cuando prueba todas las posibles formas de armarla.\\
			
		Además, el algoritmo utiliza algunas propiedades de la ronda para ser más eficiente:
		\begin{subsubsection}{Optimizaciones}
		\begin{itemize} \item Verifica que cada chica tenga al menos dos amigas, de no ser asi podemos afirmar que no se puede formar la ronda ya que cada chica debe estar tomada de la mano de dos de sus amigas.
				\item A la vez, comprueba si todas son amigas de todas. Si eso sucede podemos afirmar que la ronda existe.
				\item Por otro lado, detecta si existen grupos independientes, es decir, sin conexiones entre sí. Si esto ocurre podemos afirmar que no se puede armar la ronda ya que esta debe incluirlas a todas. 
		\end{itemize}
			
		\end{subsubsection}
			
		\begin{subsubsection}{Análisis de complejidad}
			Elegimos el modelo uniforme porque consideramos que las operaciones elementales son constantes porque todos los valores son acotados.\Pa
		
			Sea $n$ la cantidad de chicas.	
		
			El peor caso para el algoritmo es aplicar backtraking sobre una instancia $no\_ronda$ con una cantidad maximal de relaciones.
			
			Para analizar la complejidad tomamos como peor caso, la instancia donde las relaciones sean máximas (todas con todas, cada chica tiene $n-1$ amigas) y el árbol se genere completamente sólo podando cuando se repite una amiga  (nunca va a pasar por las optimizaciones y porque el algoritmo determinaria que se puede formar la ronda completando sólo la primer rama). En este caso se toma una chica y se generan todas las combinaciones posibles (sin repetir chicas). Para esto se elige la primera de donde se desprenden $n-1$ ramas posibles, de cada una de estas ramas se desprenden $n-2$, asi hasta llegar al nivel $n$.

			Se ve que: $$\displaystyle\prod_{i=1}^n (n-i) = (n-1)! \leq n!$$

			Entonces la complejidad es:  \Ode{n!}.\VSP
		
			\noindent\textbf{En función del tamaño de la entrada}\\

				El tamaño de la entrada $t$ es $n^2$ ($n=\sqrt t$). Entonces la complejidad del algoritmo es \Ode{(\sqrt t)!}. El algoritmo es exponencial.
		\end{subsubsection}
	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
		Elegimos arbitrariamente empezar la ronda por la chica $uno$ (la primera segun el archivo de entrada) ya que a los efectos de verificar si es posible armar la ronda esta elección no tiene relevancia alguna.\\
	
		Almacenamos las relaciones entre las chicas en una matriz de $n \times n$, donde $n$ es la cantidad de chicas. Cada posición $(i,j)$ de la matriz contiene un $uno$ si la chica $i$ es amiga de $j$ y un $cero$ en caso contrario.\VSP

		\begin{pseudo}
			\func{ronda\_de\_amigas}{$relaciones$}
			\tab\IF{no\_todas\_tienen\_al\_menos\_dos\_amigas(relaciones) \OR hay\_más\_de\_un\_grupo(relaciones)} \\
			\tab\tab \RET false \\
			\tab\IF{todas\_amigas\_de\_todas(relaciones)} \\
			\tab\tab \RET true \\
			\tab backtracking( relaciones )
		\end{pseudo}

		\begin{itemize}
			\item \textbf{no\_todas\_tienen\_al\_menos\_dos\_amigas:} para cada chica $c$ el algoritmo inicializa un contador de amigas en cero y recorre todas las chicas preguntando si son amigas de $c$, si es asi incrementa dicho contador. Al finalizar el recorrido verifica que el contador sea mayor o igual a dos, es decir, que la chica $c$ tenga al menos dos amigas. Si no es asi el algoritmo termina y devuelve falso.

			\item \textbf{hay\_más\_de\_un\_grupo:} para determinar si existe más de un grupo el algoritmo corre un bfs a partir de la primer chica (la primera segun el archivo de entrada). El algoritmo busca todas las amigas que todavia no hayan sido vistas considerandolas del mismo grupo. Repite este paso para cada una de las chicas alcanzadas (amigas de alguna anterior). Si el algoritmo termina y hay chicas que no fueron alcanzadas se las considera de otro grupo y por lo tanto la ronda no va a poder formarse.

La complejidad es $n^2$, donde $n$ es la cantidad de chicas. Porque el peor caso es cuando hay sólo un grupo ya que el algoritmo alcanza todas las chicas y para cada una de estas busca entre todas las chicas sus amigas.

		\item \textbf{todas\_amigas\_de\_todas:} a la vez que determina si existe una chica que tiene menos de dos amigas (no\_todas\_tienen\_al\_menos\_dos\_amigas) utiliza ese contador para saber si cada chica tiene $n-1$ amigas, es decir, es amiga de todas las demas. Si es asi, el algoritmo termina y devuelve verdadero.

		\end{itemize}

		El algoritmo de backtracking recorre las chicas, para cada una de estas chequea si es amiga de la última chica que se agrego a la ronda y si todavia no pertenece a la misma. Si es asi la agrega y repite este procedimiento (avanza). Sino significa que recorrió todas las chicas y ninguna cumple ambas condiciones por lo que comienza a retroceder.

		Cuando retrocede, saca la última chica que agrego a la ronda (la cual identificaremos con la letra $a$, además llamamos $b$ a la actual última chica en la ronda (la anterior a la que sacó)) y prosigue la busqueda desde la chica $a$ de la amiga de $b$ que ocupara la posición recientemente desocupada en la ronda. Si no hay una chica que puede ocuparla, es decir, $b$ no tiene más amigas el algoritmo sigue retrocediendo.

		Avanzando, si llega a meter a todas las chicas a la ronda y la primer chica es amiga de la última, encontró una forma de armar la ronda, termina y devuelve verdadero.

		Retrocediendo, si llega a la primer chica, termina y devuelve falso.
	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
		Las entradas para probar correctitud estan en el archivo \texttt{rondas.in, no\_rondas.in, alguna\_menos\_dos\_amigas.in, todas\_con\_todas.in, \\
		mas\_de\_un\_grupo.in}.
		Fueron elegidas para probar el comportamiento del algoritmo en todas sus variantes y probar la eficiente detección de las 'no\_rondas' cuando hay alguna chica con menos de dos amigas o cuando hay grupos aislados y de las 'rondas' cuando todas son amigas de todas.

		Para poder correr pruebas de forma eficaz, contamos con un generador aleatorio de rondas, donde para cada número de chicas $n$ variamos la densidad de las relaciones (que es el porcentaje de la cantidad máxima de relaciones posibles que se incluye en la instancia generada). Generamos 20 casos por cada $n$ desde 6 a 18 chicas, variando la densidad entre 0.3, 0.5 y 0.7.

		 Se hizo enfasis en la generación de casos promedio y peores casos (donde el algoritmo no resuelve el problema mediante las optimizaciones). Tambien forzamos a que en sólo dos instancias por cada $n$ hubiera chicas sin amigas o con sólo una amiga, donde el algoritmo optimizado se ahorra el intentar construir soluciones.

		\gra{ej2_counts.png}

		En este gráfico se muestra la cantidad de operaciones en función del tamaño de la entrada. Esta se ve acotada por la funcion factorial, cuyo parametro de entrada es la cantidad de chicas $n$ de la instancia ( $n!$). Se ven claramente en el piso del gráfico los casos en donde las optimizaciones del algoritmo no permitieron recorrer inutilmente el árbol para poder concluir que no hay solución posible.

		En este se grafica el tiempo transcurrido para cada instancia. La apreciación tambien es muy similar, ya que nuevamente aparece acotada por la funcion factorial, y se ven más abajo los casos donde se dieron lugar a las optimizaciones.		

	\end{subsection}
\end{section}

