\begin{section}{Problema 3}
	\textit{Dada una lista de ingresos y otra de egresos que contienen los horarios de ingreso y egreso de cada uno de los programadores de una empresa respectivamente, determinar la mayor cantidad de programadores que estan simultáneamente dentro de la empresa.}

	\begin{subsection}{Explicación}
		Para cada instancia tenemos una lista que contiene para cada programador su horario de ingreso a la empresa y otra con su horario de egreso. Además, tenemos guardado en cada momento la cantidad máxima de programadores en simultáneo.

Dado que ambas listas se encuentran ordenadas, nuestro algoritmo las recorre decidiendo a cada momento si se produce un ingreso o un egreso, es decir, si el horario que sigue en la lista de ingresos es anterior a la de egresos implica que hubo un ingreso, en caso contrario un egreso.

Cuando una persona ingresa a la empresa se incrementa el contador de la cantidad de programadores en simultáneo en el horario actual. Así, cuando se produce un egreso se compara si la cantidad de programadores dentro de la empresa previo a dicho egreso es mayor a la máxima cantidad de programadores en simultáneo hasta el momento, de ser así, actualizamos el máximo.

Luego se descuenta el recientemente egresado del contador parcial de cantidad de programadores en simultaneo.

Este procedimiento se repite hasta haber visto todos los ingresos, lo que nos garantiza tener el máximo correspondiente, ya que a partir de ese momento sólo se producirían egresos. Este comportamiento se ve reflejado en el siguiente pseudocódigo:

		\pagebreak
		Sea $n$ la cantidad de programadores, $j$ el índice dentro de la lista de ingresos y $k$ el índice dentro de la lista de egresos.
		
		\vspace{0.5cm}
		\begin{pseudo}
				\func{programadores\_en\_simultaneo}{$ingresos, egresos$}
(1)				\tab $max,tmp,j,k \leftarrow 0$ \\
(2)				\tab \WHILE($j< n$) &   \\
(3)				\tab \tab \IF($ingresos[j]\leq egresos[k]$) \\
(4)				\tab \tab \tab $tmp \leftarrow tmp+1$ \\
(5)				\tab \tab \tab $j \leftarrow j+1$ \\
(6)				\tab \tab \ELSE \\
(7)				\tab \tab \tab \IF($tmp>max$) \\
(8)				\tab \tab \tab \tab $max \leftarrow tmp$ \\
(9)				\tab \tab \tab $tmp \leftarrow tmp - 1$ \\				(10)				\tab \tab \tab $k \leftarrow k+1$ \\
(11)				\tab \IF($tmp>max$) \\
(12)				\tab \tab $max \leftarrow tmp$ \\
(13)				\tab \RET $max$
		\end{pseudo}




	\end{subsection}

	\begin{subsection}{Detalles de la implementación}
	Guardamos los horarios de ingreso de todos los programadores (de la misma forma que estan en el archivo de entrada, es decir, en orden creciente) en un arreglo de $strings$ (los cuales representan un horario en formato ``HH:MM:SS'') de tamaño $n$, donde $n$ es la cantidad de programadores. Además guardamos otro arreglo del mismo tamaño con los horarios de egreso.
	
	A medida que vamos recorriendo los arreglos $ingresos$ y $egresos$ necesitamos decidir si el horario de ingreso del programador $j$ es anterior o posterior al horario de egreso del programador $i$, esto lo hacemos comparando los $strings$ por menor o igual (que el horario de ingreso del programador $j$ sea el mismo que el horario de egreso del programador $i$ significa que ambos estuvieron en simultáneo en la empresa jústamente en ese horario ya que se considera que un programador permanece dentro de la empresa desde su horario de ingreso hasta su horario de egreso, incluyendo ambos extremos). Si la comparación resulta verdadera significa que el programador $j$ ingresa a la empresa por lo que incrementamos el contador de programadores en simultáneo en ese horario. En caso contrario lo decrementamos ya que el programador $i$ egresa. Antes de decrementar dicho contador verificamos si la cantidad de programadores en simultáneo previo al egreso de $i$ es mayor a $max$ (máxima cantidad de programadores en simultáneo calculada hasta el momento) y de ser necesario actualizamos $max$.

	Una vez que terminamos de recorrer la lista de ingresos, actualizamos $max$ ya que desde el último egreso visto se pueden haber producido nuevos ingresos. Una vez hecho esto tenemos determinada la mayor cantidad de programadores que estan simultáneamente dentro de la empresa.
	\end{subsection}

	\begin{subsection}{Análisis de complejidad}
			Elegimos el modelo uniforme para analizar la complejidad de este algoritmo porque el tamaño de los elementos es acotado y por lo tanto todas las operaciones elementales son de costo constante.\Pa
			
			Como cada programador tiene un ingreso y un egreso, tanto la lista de ingresos como la lista de egresos tienen longitud $n$.

El algoritmo en todos los casos recorre completamente la lista de ingresos, por lo que el peor caso es cuando el último ingreso y el último egreso corresponden al mismo programador, ya que para registrar éste último ingreso, tambien tuvo que recorrer toda la lista de egresos. Por este motivo, podemos inferir que a lo sumo se realizan $2n -1$ iteraciones. En cada una de estas tenemos un costo constante de operaciones, que no modifican la complejidad en el análisis asintótico. La complejidad algorítmica en el modelo uniforme es \Ode{n}.\VSP

		\noindent\textbf{En función del tamaño de la entrada}\\

			Como los elementos de ambas listas son de tamaño acotado, el tamaño de la entrada es proporcional a la longitud de las listas (n). Entonces la complejidad del algoritmo es \Ode{t}, donde $t$ es el tamaño de la entrada. La complejidad del algoritmo es lineal.
	\end{subsection}

	\begin{subsection}{Pruebas y Resultados}
	Las entradas utilizadas para probar correctitud están en el archivo\\ \texttt{pruebas.in}. Fueron elegidas para probar casos bordes como son: un solo programador, primero ingresan todos y luego empiezan a egresar, un ingreso se produce exactamente al mismo horario que un egreso, cada ingreso seguido del egreso correspondiente y por último ingresos y egresos mezclados.

	Por un lado, decidimos contar la cantidad de operaciones realizadas por el algoritmo en el mejor y pero caso. Para esto generamos las instancias de la siguiente manera:
	\begin{itemize}
		\item En ambos casos, elegimos un número máximo de programadores($m$) ($m=1000$ porque nos pareció suficiente para constrastar estos casos) y creamos una instancia $\forall\;n,0\leq n < m$ siendo $n$ la cantidad de programadores para esa instancia.
		\item Para las instancias que corresponden al mejor caso ingresan todos los programadores y luego egresan.
		\item Para las instancias que corresponden al peor caso los programadores que entran salen antes de que haya un nuevo ingreso, es decir, nunca va a haber más de un programador en simultáneo.
	\end{itemize}

	El objetivo de esta prueba es comparar ambos casos. Uno de ellos es el mejor caso para el algoritmo y esta acotado inferiormente por $n$ y el otro, el peor caso para el algoritmo se encuentra acotado superiormente por $n$. A pesar de que el costo del algoritmo es siempre $n$, se espera ver diferencias significativas en la cantidad de operaciones realizadas en uno u otro caso ya que en el primero de ellos es mínima porque al producirse todos los ingresos el algoritmo termina sin recorrer la lista de egresos y en el segundo máxima ya que para poder registrar el último ingreso tuvo que recorrer todos los egresos.
	
	Cada instancia correspondiente al peor caso se representa con una cruz roja mientras que cada instancia que corresponde al mejor caso está representada con una cruz azul. También está graficada en color verde la función $a*n$, ya que es la cota teórica previamente calculada con una constante aproximada calculada empíricamente.
	
	GRAFICO 1, GRAFICO 2

	Observamos que se cumple lo esperado, es decir, corroboramos empíricamente que lo analizado previamente tiene coherencia, ya que la diferencia en la cantidad de operaciones que realiza el algoritmo para resolver un problema cuya caracteristica es la del mejor caso con $n$ programadores se hace cada vez más significativa respecto a las del peor caso para un mismo $n$ a medida que dicho $n$ crece.\\
	
	Para los gráficos que siguen utilizamos un generador, que dado un número máximo de programadores $n$, genera instancias aleatorias con a lo sumo $n$ programadores. Corrimos el generador con $n$ igual a $cien$ dado que no necesitamos instancias demasiado grandes para poder apreciar el comportamiento del algoritmo.

	En los siguientes gráficos esperamos ver el comportamiento general del algoritmo en cuanto a cantidad de operaciones como en tiempo transcurrido por instancia.
	
	Las instancias se representan con una cruz roja, además en color verde aparece graficada la función $a*n$ por los motivos ya mencionados.

	\gra{ej3_counts.png}\VSP	
	
	\gra{ej3_time.png}\VSP

	En el primer gráfico se ve la función que dado el número de programadores, muestra la cantidad de operaciones realizadas por el algoritmo mientras que en el segundo se observa el tiempo consumido para procesar cada instancia, ambos en función de la cantidad de programadores.
	En los dos gráficos se puede observar que la función se encuentra acotada por una recta, con lo cual se ve sin problemas que se trata de un algoritmo que trabaja en "tiempo" lineal.

	Lo que obsevamos en los gráficos tiene coherencia con la complejidad teórica calculada. 
	En general, vemos que el algoritmo se comporta como \Thetade{n} ya que como mínimo recorre sólo toda la lista de ingresos y como máximo recorre tanto la lista de ingresos como la de egresos. Es decir, el costo del algoritmo esta acotado inferior y superiormente por $c*n$, con c constante.

	\end{subsection}

\end{section}







