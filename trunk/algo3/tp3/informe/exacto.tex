\begin{section}{Algoritmo exacto}
		\begin{subsection}{Explicación}
			El Algoritmo busca todas las formas de armar una clique utilizando la técnica de backtracking. Para esto, inicia la clique una vez desde cada vértice probando todas las combinaciones que lo incluyan, agregando vértices tal que forman un completo con los ya incluídos. Se necesita empezar una vez por cada nodo ya que la solución final podría no incluir el nodo inicial. De esta forma, se genera un árbol de backtracking teórico para cada vértice inicial. Mediante podas, evita recorrer el árbol por completo, siendo la solución final la máxima de las cliques encontradas. Como el algoritmo busca todas las cliques del grafo, la solución es la clique máxima del grafo.

		\begin{subsubsection}{Optimizaciones}
			Dado que se trata de un algoritmo de backtracking, la optimzación se basa en podar las ramas en las que estamos seguros que no va a aparecer el óptimo. Para esto tenemos que poder predecir, dado un estado actual, si es posible mejorar el óptimo encontrado hasta el momento.
			
			Por un lado, podamos las ramas que no forman un grafo completo, ya que no es solución.
			
			Por otro lado, evaluamos en cada paso del algoritmo la cantidad de vértices que falta explorar. Es decir, calculamos el tamaño de la clique máxima que podríamos formar considerando los vértices que ya estan incluídos en la solución actual. Si la cantidad de vértices que todavía no fueron evaluados más la cantidad de vértices ya pertenecientes a la clique actual es menor a la cantidad de vértices de la clique máxima encontrada hasta el momento, no tiene sentido seguir explorando esa rama ya que el tamaño de la clique máxima que se puede encontrar por ese camino es menor al tamaño de la máxima encontrada. Por este motivo, podamos esta rama.

			Además, para cada vértice que inicia la clique se intenta agregar los de mayor numeración tal que forman un completo. Por lo tanto, se evita repetir combinaciones. Supongamos que tenemos una clique de tres vértices, siendo estos el $<1,2,3>$. Con esta optimización, nunca han de analizarse los casos $<2,3,1>$; $<2,1,3>$; $<3,1,2>$ y $<3,2,1>$.
		\end{subsubsection}

		\end{subsection}
		\begin{subsection}{Detalles de la implementación}
			
			Almacenamos las relaciones entre los vértices en una matriz de $n \times n$, donde $n$ es la cantidad de vértices. Cada posición $(i,j)$ de la matriz contiene un $uno$ si existe la arista $(i,j)$ y un $cero$ en caso contrario. De esta forma se le asigna un número a cada vértice.\VSP

			A continuación, se muestra el pseudocódigo del algoritmo exacto.\\
			
			\begin{pseudo}
				\func{exacto}{matriz\_adyacencia,n}
				\tab $solucion \leftarrow \emptyset$\\
				\tab $\FOR i \TO n$\\
				\tab \tab buscar clique máxima desde el vértice $i$\\
				\tab \tab $\IF$ tiene más vértices que $solucion$\\
				\tab \tab \tab $solucion \leftarrow $ clique encontrada\\
				\RET $\#(solucion)$\\
			\end{pseudo}
			
			El algoritmo de backtracking recorre todos los vértices. Para cada uno de estos verifica si es adyacente con todos los vértices de la solución actual y si todavía no pertenece a la misma. Si es así lo agrega y repite este procedimiento (avanza). Si no, significa que recorrió todos los vértices y no logró formar una clique mayor a la encontrada, por lo que comienza a retroceder.

			Cuando retrocede, saca el último vértice $v$ que agregó a la solución y prosigue la búsqueda desde el vértice siguiente a $v$ en numeración. Si no hay un vértice que se pueda agregar, es decir, si ninguno de los siguientes forma una clique, el algoritmo sigue retrocediendo.
			
		\end{subsection}


		\newpage
		
		\begin{subsection}{Complejidad temporal}

		%PONELE QUE ESTA SEA LA COMPLEJIDAD... HABRÍA QUE CONSULTAR, PORQUE ES ME DIO FEA
		%ROCK, DAME NENA. NENA, DAME ROCK! ROCK'N ROLLENNENNENNNNNN

		El algoritmo de Max\_Clique exacto utiliza la técnica de backtracking, con lo que genera un árbol donde cada rama es una posible solución, y esta se desarrolla hasta que encuentra una solucion o el algoritmo mediante una optimizacion "se da cuenta" que no hay forma de encontrar el clique óptimo y la "poda".
		Ya que las optimizaciones podan constantemente las ramas donde los cliques que no lleguen a ser el óptimo, se hace muy difícil encontrar el $peor$ $caso$ del algoritmo, que sería el caso donde las podas sean las mínimas posibles, con una cantidad máxima de cliques máximos, con lo que decidimos plantear un caso hipotético donde el árbol de backtracking se genere sin podas, verifícando para cada nodo $i$ las posibles cliques que contengan a $i$, y todos los nodos posibles entre $i$ y $n$. Como dijimos, esto es un caso hipotético, donde el algoritmo tiene un comportamiento menos eficiente, y de esta forma lo que nos da es una cota un tanto $gruesa$ con respecto a la real, pero que a fines prácticos nos da una idea de que aún en el peor caso, el algoritmo será un tanto mas eficiente respecto a la cota calculada. 

		Sea $G$ un grafo con conexo, con $n$ nodos y relaciones máximas, es decir, siendo $m$ la cantidad de ejes del grafo, $m = n(n-1)$. $Es decir, G = K_n$
		Al tratarse de un caso hipotético asumiremos que el algoritmo no efectua podas ni utiliza las optimizaciones que ayudan a terminar el algoritmo antes que recorra todos los nodos, es decir, que solo verificará para cada nodo $i$, con $0 < i < n$, los cliques posibles que contengan a $i$, junto con todos los nodos posibles entre $i$ y $n$, y terminara cuando $i$ sea igual a $n$

		De esta forma, para cada nodo $i$ generará su arbol de cliques correspondiente,y así tendremos un arbol de $n-i$ factorial nodos, que son todas las posibles cliques máximas de $n$-$i$ nodos, con $i$ como raiz.

		Como este procedimiento se repite con $i$ desde 1 a $n$ nos queda planteada una sumatoria: $\sum_{i=1}^{n}{i!}$ = $1 + 2 + 3! + ... + n!$ $\leq$  $n.n!$
		
		
		
		\end{subsection}
\end{section}

