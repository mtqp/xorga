\begin{section}{Tabu-Search}
	\begin{subsection}{Explicación}
		Finalmente implementamos una metaheuristica, es decir, una heurística que guía otra heurística, en este caso la búsqueda local del ejercicio anterior.

		El \texttt{Tabu-Search} permite evitar que la heurística de búsqueda local se estanque en óptimos locales cuando en realidad fuera de la vecindad existía una solución óptima global (mejor que la local).
		Para lograrlo, permite al algoritmo perseguir una solución peor que la mejor obtenida mediante búsqueda local, por una cantidad máxima de iteraciones.
		Pasada esta cantidad, con-\\sideramos que el algoritmo ya buscó lo suficiente por lo que volvemos a la solución inicial y buscamos por otro camino, es decir, comenzamos a sacar los vértices en otro orden lo que denominaremos 'rotacion'.
		%y la mejor solución encontrada hasta el momento debe ser la óptima.

		Para no revisar las vecindades que se revisaron anteriormente (que son muy cercanas a la vecindad actual),
		cada vez que decidimos movernos a otra vecindad porque tenemos un nuevo aspirante a óptimo (más allá de que sea peor que la mejor solución que encontramos hasta el momento, pero lo llamamos así por su similitud con el mismo en la búsqueda local)
		prohibimos revertir el cambio que hicimos para llegar del aspirante anterior al nuevo, o sea, prohibimos volver a agregar el vértice que sacamos.
		
		Cada vez que logramos mejorar, es decir, encontramos una clique de tamaño mayor a la máxima clique vista hasta el momento actualizamos la solución.
		Repetimos este procedimiento hasta agotar la máxima cantidad de iteraciones permitidas sin mejorar desde cada camino (rotación). Una vez que ocurre esto, el algoritmo termina, siendo la solución final la solución actual, es decir, la clique de mayor tamaño que logro encontrar.(Figura \ref{fig:seguimiento_busqueda_tabu})\Pa


		La siguiente figura no representa el seguimiento completo del algoritmo, sólo se incluye la parte más relevante, es decir, se muesta la rotación donde logra encontrar el óptimo.  Las rotaciones consisten en empezar a sacar en un orden distinto al que se comenzo a sacar anteriormente.

			% --- Figura seguimiento algoritmo constructivo ---
			\begin{figure}[H]
				\centering
		    	\includegraphics[scale=0.5]{tabu_search/seguimiento.eps}
			    \caption{Ejemplo de la heurística de búsqueda tabú}
			    \label{fig:seguimiento_busqueda_tabu}
			\end{figure}

		La heurística de búsqueda local nos da la clique formada por $<4,5,6>$. En una de las rotaciones, saca el vértice $cinco$ intentando formar una clique de mayor tamaño con $<4,6>$, al no poder hacerlo, retira el $seis$ (es decir, ahora el $seis$ y el $cinco$ son tabú). Es entonces que encuentra una nueva clique de cuatro nodos y actualiza la solución parcial con esta. El algoritmo continúa haciendo rotaciones sobre la nueva solución intentando agrandar la clique durante la cantidad de iteraciones permitidas y volviendo a permitir agregar los vértices tabú después de pasada su cantidad de iteraciones tabú. En este grafo en particular, no logra ninguna nueva mejora, siendo la clique observada en el último grafo de la figura, la solución que devuelve el algoritmo, así como el óptimo.



		\begin{comment}
		Esto lo implementamos mediante un arreglo de vértices (los índices representan los vértices), donde para cada uno guardamos la cantidad de iteraciones que falta para que deje de ser tabú (el algoritmo lleva la cuenta de las iteraciones).
		Luego, cuando revisamos las vecindades de un aspirante, evitamos aquellas donde la modificación implica agregar un vértice tabú.

		Los parámetros que indican cuanto tiempo una variable queda tabú y cuantas veces se puede iterar sin encontrar un nuevo óptimo antes de cortar el algoritmo, los buscamos empíricamente viendo los resultados obtenidos con distintos parámetros, y son bla y bla respectivamente.
		CAMBIAR LOS PARAMETROS!!!
		\end{comment}
	\end{subsection}
	\begin{subsection}{Detalles de la implementación}
		Almacenamos las relaciones entre los vértices en una matriz de $n \times n$, donde $n$ es la cantidad de vértices. Cada posición $(i,j)$ de la matriz contiene un $uno$ si existe la arista $(i,j)$ y un $cero$ en caso contrario. De esta forma se le asigna un número a cada vértice.

		A continuación, se muestra el pseudocódigo de la heurística de búsqueda tabú.\\

		Sea $n$ la cantidad de vértices del grafo.

		\begin{pseudo}
			\func{busqueda\_tabu}{solucion,tamanyo,matriz\_adyacencia}
			\tab $\IF tamanyo==1 \OR tamanyo==n$\\
			\tab \tab $\RET tamanyo$\\
			\tab $grados[n] \leftarrow ordenar\_grados(matriz\_adyacencia)$\\
			\tab $\WHILE mejore$\\
			\tab \tab $\FOR c \TO tamanyo$\\
			\tab \tab \tab $inicializar\_estructuras$\\
			\tab \tab \tab $rotar\_clique$\\
			\tab \tab \tab $\WHILE puedo\;seguir$\\
			\tab \tab \tab \tab $sacar\_de\_clique$\\
			\tab \tab \tab \tab $poner\_tabu$\\
			\tab \tab \tab \tab $formar\_completo(actual,matriz\_adyacencia)$\\
			\tab \tab \tab \tab $\IF tam\_actual>tamanyo$\\
			\tab \tab \tab \tab \tab $agrandar\_clique(actual,lista\_tabu)$
			\tab \tab \tab \tab \tab $actualizar\_solucion$
			\tab \tab \tab \tab \tab $c \leftarrow tamanyo$\\
			\tab \tab \tab \tab $\ELSE$\\
			\tab \tab \tab \tab \tab $restar\_tabu$\\
			\tab \RET $tamanyo$\\
		\end{pseudo}

		En la implementación mantenemos la solución actual en una lista de vértices. La lista inicia ordenada de mayor a menor según los grados, esto lo hacemos para empezar a sacar desde el de menor grado ya que consideramos que es el que tiene más probabilidades de estar condicionando la clique. Además, tenemos un arreglo de tipo bool de tamaño $n$ donde el índice representa a los vértices y esta seteado en $verdadero$ si y sólo si el vértice pertenece a la clique actual. Mantenemos ambas estructuras porque usamos la lista para determinar el orden en que se eliminan (rotarla tiene costo constante) y el arreglo para verificar la pertenencia de un vértice a la clique (ya que esta operación en esta estructura de datos tiene costo constante).
		Por otro lado, mantenemos un arreglo de vértices (los índices representan los vértices), donde para cada uno guardamos la cantidad de iteraciones que falta para que deje de ser tabú una vez que son eliminados de la clique actual (el algoritmo lleva la cuenta de las iteraciones). Esto lo hacemos para no revertir los cambios recientemente hechos y cuando revisamos las vecindades de un aspirante, evitamos aquellas donde la modificación implica agregar un vértice tabú.

		La primer cláusula \texttt{if} verifica si la solución de búsqueda local encontró la clique tanto completa como la de un elemento. En ambos casos no tiene sentido aplicar el tabú search ya que, si encontró el completo, esta solución no podrá ser mejorada, al contener todos los vértices. Si sólo encontró un vértice, implica que el de grado mayor en el grafo es de grado cero, por lo tanto, todos sus vértices son de grado cero.

		El valor de verdad de la guarda del \texttt{while} $puedo\_seguir$ viene dado por la conjunción entre $tam\_actual \neq 1$, $\neg mejore$ e $iteracion<iteraciones$.
		Pedimos que el tamaño de la clique actual sea distinto de $uno$ ya que nos interesa movernos a soluciones vecinas. Si el tamaño es $uno$ en esa iteración saca el último vértice de la clique por lo que se pierde referencia a la misma moviéndose inmediatamente al primer vértice segun la numeración que no esté tabú.
		Por otro lado, el \texttt{while} itera mientras no logre mejorar para forzar la salida del ciclo cuando encuentre una clique de mayor tamaño que la actual y así empezar a sacar vértices desde la primer rotación (ya que también se fuerza la salida del \texttt{for}).
		La última condición es para asegurar la salida del ciclo, ya que podría no mejorar nunca y ciclar entre diferentes cliques. Además, esto determina la cantidad de iteraciones que le permitimos buscar sin lograr mejorar, es un parámetro 'iteraciones' que ajustamos mediante pruebas (ver sección 5.5).
		\begin{itemize}
			\item \texttt{ordenar\_grados: } En la implementación, el arreglo $grados$ es de tipo tupla donde la primer componente representa el vértice y la segunda el grado. Dicho arreglo está ordenado según la segunda componente en forma decreciente. Lo ordenamos con el algoritmo de Quick Sort de $STL$.
				
			Para setear el grado de un vértice $i$ tenemos un contador inicializado en $cero$. Recorremos la columna de la matriz de adyacencia correspondiente a dicho vértice e incrementamos el contador por cada posición $(i,j)$ igual $uno$.	

			\item \texttt{rotar\_clique: } Dado que fijar la pertenencia de un vértice a la clique condiciona el resultado final, el orden en que se eliminen los vértices puede hacer la diferencia entre un buen resultado y uno malo, a pesar de encontrar un buen criterio para hacerlo. Por este motivo, decidimos empezar eliminando de menor a mayor grado, y en cada iteración rotar la lista para sacar los vértices en otro orden.
			
			\item \texttt{sacar\_de\_clique: }Esta función saca de la lista el último elemento (el de menor grado entre los vértices con una misma 'antiguedad' en la clique) y setea en $falso$ la posición correspondiente en el arreglo (dejando tabú la operación inversa (agregarlo a la clique) tantas iteraciones como lo indique el parámetro 'tabu'(Ver sección 5.5)), es decir, excluye el vértice de la solución actual. Además, decrementa la variable que indica el tamaño de la clique.
			
			\item \texttt{formar\_completo: } Esta función se encarga de buscar entre los vértices que actualmente no pertenecen a la clique e intenta agregarlos (agrega todo vértice que forma un completo con los ya pertenecientes), con el objeto de conseguir una de mayor tamaño. Para saber si agregarlo determina una solución al problema debemos verificar que forme un completo con los vértices ya incluídos. Para esto recorremos todos los vértices del grafo y para cada uno que pertenezca a la solución parcial chequeamos que sea adyacente al que pretendemos agregar. Si esto ocurre podemos agregarlo y agrandar la clique. Elegimos el vértice a agregar de mayor a menor grado.
			
			\texttt{Observaciones: }
			\begin{itemize}
				\item Al agregar condicionamos la clique resultante al igual que pasa al sacar sin hacer rotaciones (depende del orden en que lo hagamos la calidad de la solución). Es decir, encontrar una mejor solución depende del orden en que agreguemos los vértices, podriamos también hacer rotaciones para agregar pero esto aumentaría en $n$ la complejidad. Buscando un equilibrio entre eficiencia y calidad de la solución, decidimos que hacer ambas rotaciones (agregar, sacar) tenia una complejidad mayor a la que pretendemos aceptar, no hacer ninguno implica perdernos de encontrar mejores soluciones y obtener así soluciones muy precarias. Entonces elegimos arbitrariamente hacer las rotaciones sólo para sacar.

				\item Si el algoritmo vuelve a la solución inicial y todavía le restan iteraciones del \texttt{while} anidado, queremos evitar que repita exactamente el mismo procedimiento pasando nuevamente por soluciones ya visitadas por lo que forzamos la salida y aplicamos una rotación a dicha solución para explorar nuevas posibilidades.
			\end{itemize}

			\item \texttt{agrandar\_clique: } Esta función itera los vértices que están en la lista tabú e intenta agregarlos a la clique actual. Esto es porque como ya conseguió una solución mejor lograr agregar algún vértice que esta tabú contribuye aún más a la solución.

			\item \texttt{restar\_tabu: } Para cada vértice tal que tiene tabú mayor a $cero$ decrementa la cantidad de iteraciones que va a permanecer tabú.

			Tanto en $formar\_completo$ como en $agrandar\_clique$ los vértices que agregamos a la lista de la clique actual los ponemos al principio de la misma, es una forma de poner tabú al menos tantas iteraciones como vértices había en la clique previo a agregarlos la operación inversa, sacarlos (ya que se saca siempre el último de la lista).
		\end{itemize}
	\end{subsection}

	\begin{subsection}{Desventajas}
		La numeración de los nodos toma un papel crucial a la hora de obtener una solución, es así que en casos patológicos puede pasar que:

		El algoritmo visite soluciones anteriormente exploradas ya que como se mueve constantemente de solución, puede eventualmente volver a la solución inicial (ejemplo: la búsqueda local nos da un clique de dos vértices que se encuentran en un ciclo, y este ciclo está unido a un completo de tres o más vértices). Si los vértices del completo tienen mayor numeración a los del ciclo, el algoritmo ciclaría tomando en cada iteración (mientras no se cumpla la restricción de iteraciones pasadas como parámetros) como solución dos de los vértices pertenecientes al ciclo, sin ver el completo.

		Para evitar pasar varias veces por las mismas soluciones, por cada iteración del \texttt{while} anidado se verifica si vuelve a la solución inicial, de ser así, se fuerza la salida y se procede a la siguiente rotación de la clique.
		A pesar de solucionar este problema para casos particulares como el que mencionamos (donde se parte de una solución y a través eliminar y agregar vértices se llega nuevamente a la solución inical), pueden existir casos donde se repitan soluciones desde distintas rotaciones de la clique inicial. Estos casos no son advertidos por el algoritmo.

		El siguiente seguimiento refleja el problema de la numeración (Figura \ref{fig:seguimiento_busqueda_tabu} y \ref{fig:seguimiento_busqueda_tabu_continuacion}).

			% --- Figura seguimiento algoritmo busqueda tabu ---
			\begin{figure}[H]
				\centering
		    	\includegraphics[scale=0.5]{tabu_search/segCasoMalo.eps}
			    \caption{Caso malo para la heurística de búsqueda tabú}
			    \label{fig:seguimiento_busqueda_tabu}
			\end{figure}

		En la primer rotación, el algoritmo saca el vértice $dos$ (ya que es el de menor grado entre los pertenecientes a la clique) tiene dos caminos para seguir, agregar el $cuatro$ o el $cinco$. En el primero, se encontrará con un ciclo de cuatro nodos, sin poder agrandar la clique. En el segundo caso, encontrará una clique de tres, pudiendo mejorar y además encontrar el óptimo para este caso. Como ya dijimos, al tener dos vértices de igual grado, el algoritmo elige el de menor numeración, en este caso el $cuatro$. Por esto, se mueve a la solución $<3,4>$ agregando el $cuatro$ al principio de la lista de la clique, por lo que en la siguiente iteración saca el vértice $tres$ moviéndose a la clique $<1,4>$ por el mismo motivo que antes prosigue retirando el vértice $4$, como todos sus adyacentes se encuentran tabú no puede agregar nada quedando la clique actual de tamaño $uno$ por lo que sale del ciclo \texttt{while} y procede a la siguiente rotacion de la clique inicial $<2,3>$ (Figura \ref{fig:seguimiento_busqueda_tabu_continuacion}).

		Por lo tanto, en esta rotación, el algoritmo no puede encontrar la clique de tres.

			\begin{figure}[H]
				\centering
		    	\includegraphics[scale=0.5]{tabu_search/segCasoMalo_cont.eps}
			    \caption{Caso malo para la heurística de búsqueda tabú}
			    \label{fig:seguimiento_busqueda_tabu_continuacion}
			\end{figure}

		En la segunda y última rotación, comienza por quitar el vértice $tres$, dejándolo tabú, y no pudiendo tomar otro vértice mas que el $uno$. Recorre el camino dado por los vértices $2,1,4$. Al llegar al $cuatro$, posee todos sus vértices adyacentes tabú, por lo que no puede seguir. Termina porque probó mejorar en todas sus rotaciones, sin poder lograrlo.

	\end{subsection}

	\begin{subsection}{Complejidad temporal}
			En un pricipio el algoritmo inicializa el arreglo de los $grados$ y lo ordena, lo que tiene un costo de $n^2$ ya que se utiliza el algoritmo de ordenamiento $QuickSort$. Luego, obtiene la solución inicial mediante la heurística de busqueda local que como ya vimos tiene un costo de $n^4$.

			La función $rotar\_clique$, $sacar\_de\_clique$ y $poner\_tabu$ tienen costo\\ constante ya que constan sólo de indexaciones, asignaciones y operaciones elementales sobre listas.

			La función $formar\_completo$ itera por todos los vértices y para cada uno de estos verifica si es factible agregarlo a la clique, lo cual tiene un costo de $n^2$ ya que dicha verificación consiste en recorrer todos los vertices del grafo y ver que el vértice que se pretende agregar es adyacente a cada uno de estos. Además, se concatena la lista de los vértices agregados con la lista de la clique actual lo que tiene un costo constante.

			La función $agrandar\_clique$ tiene costo $n^2$ ya que no es más que una llamada a la función $formar\_completo$ con todos los vértices permitidos, es decir, previo a la llamada se resetea el arreglo $tabu$.

			 La cantidad de iteraciones del primer ciclo \texttt{while} se puede acotar por $n$ (seria un caso hipotetico en el que la mejora sea sólo de un vértice, es decir, se inicie con la clique trivial (tamaño $uno$) y en cada iteración de este ciclo se logre incrementar en uno el tamaño de la clique). En cada una de estas iteraciones hay un ciclo \texttt{for} que se ejecuta a lo sumo tantas veces como el tamaño de la clique, también puede ser acotado por $n$, dentro de este ciclo se resetean las estructuras (la lista y los arreglos) lo que tiene un costo lineal. Además, hay un ciclo \texttt{while} (dentro del for) que se ejecuta a los sumo $n$ veces y en cada una de las iteraciones hay una llamada a la función $sacar\_de\_clique$ con costo constante y $formar\_completo$ con costo $n^2$, en caso de lograr mejorar hay una llamada a la función $agrandar\_clique$ con costo $n^2$, en caso contrario, hay una llamada a la función $restar\_tabu$ de costo lineal (recorre todos los vértices decrementando la cantidad de iteraciones que permaneceran tabú). Entonces la complejidad del \texttt{while} anidado es:  \Ode{n*(\Ode{sacar\_de\_clique} + \Ode{formar\_completo} + \Ode{agrandar\_clique} + \Ode{restar\_tabu})} = \Ode{n*(1+n^2+n^2+n)} = \Ode{n^3}.

			 Finalmente, se deduce que la complejidad final del algoritmo es $n^5$ ya que acotamos tanto la cantidad de iteraciones del cliclo \texttt{while} como del \texttt{for} por $n$, entonces tenemos \Ode{n*n*\Ode{while\_anidado}}=\Ode{n^5}.\Pa
			 
			 \texttt{Observación: } En la función $formar\_completo$ para ver si es factible agregar un vértice a la clique en vez de recorrer todos los vértices del grafo como hacemos, se podria sólo recorrer los vértices pertenecientes a la clique ya que están en una lista, pero la complejidad sería la misma y deberiamos ir agregando a la lista a medida que se decide agregar un vértice (para considerarlo en las proximas verificaciones) y esto no nos permite hacerlo en el orden deseado (ya que queremos agregar al principio de la lista de la clique actual de menor a mayor grado y los recorremos de mayor a menor grado). Como ya mencionamos esto no mejoraria la complejidad asintotica y aumentaria la complejidad de comprensión del código.
	\end{subsection}

	\begin{subsection}{Parámetros de la heurística tabú}
		La heurística de busqueda tabú hace uso de dos parámetros, los cuales tuvimos que ajustar de manera de conseguir los mejores resultados posibles, mejores en el sentido de relación calidad de la solución y eficiencia en terminos de tiempo del algoritmo.

		Uno de los parámetros es para determinar la máxima cantidad de\\ iteraciones que le permitimos al algoritmo buscar (explorar la vecindad) sin lograr mejorar. Para ajustar este parámetro generamos $300$ instancias aleatorias donde cada una es un grafo de $100$ vértices (las relaciones entre ellos son aleatorias, y por lo tanto las cliques que se forman). Para llevar a cabo las pruebas ejecutamos las instancias modificando el valor del parámetro. Creemos que dicho parámetro debe depender de la cantidad de vértices del grafo. Fijar un valor no tendría sentido ya que para grafos chicos un valor grande sería inutil (saldría del ciclo por la condición de 'tamaño de la clique igual a uno' o visitaría soluciones ya exploradas) y para grafos grandes un valor chico devolvería probablemente soluciones muy malas ya que se le daría muy pocas oportunidades de explorar la vecindad. Por este motivo, decidimos que el parámetro iba a ser un porcentaje de la cantidad de vértices del grafo. En el siguiente gráfico se ven los resultados para un $20$, $40$, $60$, $80$, $100$, $200$ y $300$ por ciento de la cantidad de vértices del grafo y para el algoritmo exacto. Se muestra la cantidad de instancias (entre las $300$) que devuelven una determinada cantidad de vértices como resultado, es decir, se grafica la cantidad de instancias en función del tamaño de la clique que logra encontrar el algoritmo.(Figura \ref{fig:Ajuste_del_parametro_iteraciones})

	\begin{figure}[H]
		\centering
		  	\includegraphics[width=9cm,angle=-90]{tabu_search/iteraciones.eps}
		\caption{Pruebas de calidad para ajustar el parámetro iteraciones}
		\label{fig:Ajuste_del_parametro_iteraciones}
	\end{figure}

	En el gráfico (Figura \ref{fig:Ajuste_del_parametro_iteraciones}) se puede observar que con un $20$ y $40$ por ciento del total de vértices del grafo, la calidad de la solución provista por la heurística de búsqueda tabú es muy mala en términos de calidad, es decir, los resultados distan considerablemente del óptimo (de los resultados del algoritmo exacto). Por este motivo, decidimos descartar estos valores para el parámetro, dado que el objetivo es encontrar un equilibrio calidad-tiempo de ejecución y estos resultados carecen de calidad.

	Por otro lado, vemos que con un $100$, $200$ y $300$ por ciento los resultados son muy buenos en cuanto a calidad, es decir, están muy próximos a los resultados provistos por el algoritmo exacto por lo que por el momento son valores que podríamos elegir, aunque creemos van a tener un costo elevado en cuanto a tiempo de ejecución.

	Los valores de $60$ y $80$ por ciento que se encuentran en el medio de los anteriores, es decir, las soluciones que provee la heurística de búsqueda tabú para estos valores no es tan 'mala' como lo es para los primeros valores ni tan 'buena' como para los segundos son candidatos a ser elegidos ya que muy probablemente sean los que proveen el equilibrio calidad-eficiencia que buscamos.\Pa

	Para poder terminar de decidir el valor del parámetro, hicimos pruebas de tiempo (en segundos) en función de la cantidad de vértices del grafo. Para esto generamos $100$ instancias aleatorias donde la cantidad de vértices para cada una es $8*x+1$ siendo $x$ el número de instancia (Figura \ref{fig:Ajuste_del_parametro_iteraciones2}). El objetivo de este gráfico es decidir qué valores según el gráfico anterior (Figura \ref{fig:Ajuste_del_parametro_iteraciones}) son aceptables y finalmente decidir cuál es el valor adecuado.

	\begin{figure}[H]
		\centering
		    	\includegraphics[width=9cm,angle=-90]{tabu_search/time.eps}
		\caption{Pruebas de tiempo para ajustar el parámetro iteraciones}
		\label{fig:Ajuste_del_parametro_iteraciones2}
	\end{figure}
	
	En el gráfico (Figura \ref{fig:Ajuste_del_parametro_iteraciones2}) observamos que para el valor $100$ del parámetro, para instancias grandes el tiempo de ejecución es considerable. Por este motivo, directamente no graficamos los tiempos para los valores $200$ y $300$ ya que dichos valores serían descartados por ser muy costosos en tiempo de ejecución.
	Luego del análisis, tenemos como candidatos a ser el valor del parámetro a $60$ y $80$. Ambos valores satisfacen lo buscado, equilibrio calidad-tiempo de ejecución. Cualquiera de ellos sería adecuado para el algoritmo. Nos decidimos por $60$ dado que preferimos ganar un poco en tiempo de ejecución debido a que la complejidad de este algoritmo es $n^5$ y no es menor una pequeña diferencia en la constante.\VSP


		El otro parámetro es para determinar la máxima cantidad de iteraciones que un atributo permanece tabú, en este caso agregar un vértice. Para ajustar este parámetro usamos las mismas instancias que para los tiempo del gráfico anterior (Figura \ref{fig:Ajuste_del_parametro_iteraciones}). Para realizar las pruebas variamos el parámetro entre los valores $10$, $20$, $40$, $60$, $80$ y $100$ donde estos representan un porcentaje del tamaño de la clique desde la que se comienza a sacar los vértices. Creemos que este parámetro debe depender del tamaño de la clique ya que si parte de una clique chica y el valor es grande la vecindad va a estar demasiado restringida dado que la misma también va a ser chica, si la clique desde la que parte es grande y el valor chico muy probablemente vuelva a soluciones ya exploradas y no es lo que queremos. En el siguiente gráfico se muestra la cantidad de instancias (entre las $100$) que devuelven una determinada cantidad de vértices como resultado, es decir, se grafica la cantidad de instancias en función del tamaño de la clique que logra encontrar el algoritmo.(Figura \ref{fig:Ajuste_del_parametro_tabu}).

	\begin{figure}[H]
		\centering
		    	\includegraphics[width=9cm,angle=-90]{tabu_search/max_tabu2.eps}
		\caption{Pruebas de calidad para ajustar el parámetro tabu}
		\label{fig:Ajuste_del_parametro_tabu}
	\end{figure}

	A partir del gráfico consideramos que el valor más adecuado para este parámetro es el $40$ ya que vamos a elegirlo según la calidad de solución que proporcione. En el gráfico se observa que el valor que se mantiene más próximo al exacto es este.

	Una vez que fijamos el valor del parámetro notamos que debía tener una cota inferior, dado que si el valor era demasiado chico el tamaño de la clique que encuentra el algoritmo esta muy lejos del óptimo. En otras palabras, si el valor del parámetro 'tiende' a $uno$ el resultado de la heurística de búsqueda tabú es muy similar al de la búsqueda local. Por este motivo, el valor del parámetro termina siendo el máximo entre el $40$ por ciento del tamaño de la clique inicial y $tres$. Elegimos el valor $tres$ pensando en que recien iniciando desde una clique de $tres$ vértices nos interesa remarcar la diferencia en el comportamiento con respecto la búsqueda local y poder así sacar varios vértices a la vez.
	\end{subsection}
\end{section}
