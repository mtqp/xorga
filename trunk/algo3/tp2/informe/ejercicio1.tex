\begin{section}{Problema 1}

	\textit{Sea $s = (s_1,s_2,..,s_n)$ una secuencia de números enteros. Determinar la mínima cantidad de elementos de $s$ tales que al ser eliminados de la secuencia, el resto de los elementos forman una secuencia unimodal.}

	\begin{subsection}{Explicación}

		La resolución del problema consiste en considerar cada uno de los elementos de la secuencia dada como
		posible máximo de una subsecuencia (al que nos referiremos como ``pico"), tal que sea unimodal. Cada 
		subsecuencia unimodal tiene longitud máxima, es decir, contiene la subsecuencia creciente hasta el pico
		y la subsecuencia decreciente desde el pico, ambas con la mayor cantidad de elementos posibles. Al no
		necesitar explicitar los elementos de la secuencia, la única información que aporta a la solución del
		problema es la longitud de cada subsecuencia. De esta manera, para determinar la mínima cantidad de
		elementos que se deben eliminar para transformar la secuencia dada en unimodal, basta con conocer
		la diferencia entre la longitud de la secuencia original y el máximo de las longitudes de cada
		subsecuencia unimodal. 		

	\end{subsection}

	\newpage

	\begin{subsection}{Detalles de la implementación}
		
		Para determinar la máxima longitud de la subsecuencia creciente y decreciente hasta cada elemento,
		utilizamos la técnica de programación dinámica.
		
		Sea la secuencia dada $S=[s_1,s_2,...,s_n]$ y $C=[c_1,c_2,...,c_n]$ \\
		con $c_i=\displaystyle\max_{0<j<i}\{ c_j / s_j < s_i \}+1$ ($\forall\;i\in\mathbb{N}, 0<i\leq n$), es 
		decir, para cada $i$ tenemos en $c_i$ la máxima longitud de la subsecuencia creciente que incluye a
		$s_i$. Análogamente, se define $D$ como la secuencia que contiene las máximas longitudes de las
		subsecuencias decrecientes de $S$.
		
		El algoritmo que calcula la solución implementa tanto $C$ como $D$.	
		Para obtener la máxima longitud de la subsecuencia creciente hasta el índice $i$, itera
		por todos los índices $j<i$ en $C$, buscando el máximo valor entre los $c_j$ tales que $s_i$ sea mayor
		que	$s_j$. 
		Esto asegura que en la posición $c_i$ está la máxima longitud de la subsecuencia creciente
		que incluye a $s_i$ ya que, si existiese otra subsecuencia de mayor longitud a la que se pueda 
		agregar $s_i$, se podría agregar el $s_i$ a esa secuencia y así obtener una con más cantidad de 
		elementos, siendo el valor de $c_i$ la longitud de dicha secuencia más 1. Para calcular $D$,
		invertimos $S$ y aplicamos el mismo	procedimiento que para $C$, quedando en $d_i$ la máxima longitud
		de la subsecuencia decreciente que incluye a $s_{n-i}$.

		Luego de calcular $C$ y $D$ el algoritmo determina la mínima cantidad de elementos a ser eliminados de
		la secuencia tales que el resto de los elementos forman una secuencia unimodal, de la siguiente forma:
		
		\vspace{0.5cm}
		\begin{pseudo}
			\func{secuencia\_unimodal}{$secuencia,C,D$}
			\tab $max\_long \leftarrow 0$ \\
			\tab \FOR $i=1$ \TO $n$ \\
			\tab \tab $long\_secuencia\_unimodal\leftarrow C[i]+D[n-i]-1$ \\
			\tab \tab \IF $ long\_secuencia\_unimodal >  max\_long$ \\
			\tab \tab \tab $max\_long \leftarrow long\_secuencia\_unimodal$ \\
			\tab \RET longitud($secuencia$)-$max\_long$
		\end{pseudo}

	\end{subsection}

	\newpage

	\begin{subsection}{Análisis de complejidad}
		Como hemos visto anteriormente, nuestro algoritmo utiliza la técnica de programación dinámica. Esta consta de 
		reutilizar información previamente calculada para llegar al resultado final. En el análisis de la complejidad veremos como la
		aplicación de la técnica previamente mencionada, ha permitido conseguir un algoritmo polinomial.
	
		El algoritmo $long\_max\_creciente$ es el que utiliza la técnica de programación dinámica, calculando para cada elemento 
		$i$ de la secuencia original la máxima longitud de la subsecuencia creciente y decreciente que lo incluye, iterando 
		por todos los índices $j<i$ ($\forall i\; 0 \leq i < n$), sabiendo que para cada $j$ ya esta calculada la longitud de 
		la subsecuencia creciente más larga que lo incluye.\\

		Sea $n$ la longitud de la secuencia dada, $max\_long\_creciente$ la secuencia que guarda en cada posición la máxima 
		longitud de la subsecuencia creciente.\\

		\begin{pseudo}
			\func{long\_max\_creciente}{$secuencia, max\_long\_creciente$}
			\tab $max\_long\_creciente[0] \leftarrow 0$ 		\Ode{1} \\
			\tab \FOR $i=1$ \TO $n$ \\
			\tab \tab $max\_long \leftarrow 0$ 			\Ode{1} \\
			\tab \tab \FOR $j=i-1$ \TO $0$ 				\Ode{i}\\
			\tab \tab \tab \IF $ secuencia[j] <  secuencia[i] \AND max\_long\_creciente [j] > max\_long)$ \Ode{1} \\
			\tab \tab \tab \tab  $max\_long \leftarrow max\_long\_creciente[j] $ 		\Ode{1} \\
			\tab \tab $max\_long\_creciente[i] \leftarrow max\_long+1$ 			\Ode{1} \\
		\end{pseudo}

		Podemos ver dentro de cada ciclo ($for$) que todas las asignaciones tienen costo constante, así como también la guarda 
		del $if$. De esta manera podemos concluir que por cada iteración del $for$ anidado tenemos en el peor caso el costo 
		de la guarda del if, más el costo de la asignación dentro del mismo, con costo constante.

		El ciclo anidado iterará para cada $i$, $i-1$ veces, siendo los valores posibles de $i$ desde $1$ hasta $n$.

		La complejidad de dicho algoritmo viene dada por: $\sum_{i=0}^{n-1} i = \frac{n*(n-1)}{2}$

		Esta sumatoria, se coindice entonces con el costo de la función $long\_max\_creciente$. La cantidad de operaciones que 
		realiza este algoritmo es \Ode{n^2}.\\
	
		El algoritmo encargardo de devolver el resultado del problema es $secuencia\_unimodal$, el cual utiliza el algoritmo 
		descripto anteriormente y realizar algunas otras operaciones que se detallarán a continuación para concluir con el análisis 
		de complejidad.\\
	
		\vspace{0.5cm}
		\begin{pseudo}
			\func{secuencia\_unimodal}{$secuencia, n$}
			\tab $C[n]$\\
			\tab $D[n]$\\
			\tab $R \leftarrow reverso(secuencia)$ 		\Ode{n} \\
			\tab $long\_max\_creciente(secuencia,C)$ 	\Ode{n^2}\\
			\tab $long\_max\_creciente(R,D)$		\Ode{n^2}\\
			\tab $max\_long \leftarrow 0$			\Ode{1}\\
			\tab \FOR $i=1$ \TO $n$				\Ode{n}\\
			\tab \tab $long\_secuencia\_unimodal\leftarrow C[i]+D[n-i]-1$ 	\Ode{1}\\
			\tab \tab \IF $ long\_secuencia\_unimodal >  max\_long$ 	\Ode{1}\\
			\tab \tab \tab $max\_long \leftarrow long\_secuencia\_unimodal$ \Ode{1}\\
			\tab \RET longitud($secuencia$)-$max\_long$ 			\Ode{1}\\
		\end{pseudo}
		
		La función reverso que toma una secuencia y devuelve otra con los elementos en orden inverso tiene costo lineal, en función 
		de la cantidad de elementos, ya que itera una vez por la secuencia original ($desde\; i=0\; hasta\; n-1$), guardando cada valor en 
		la posición $n-1-i$ de la secuencia resultante. Cabe destacar que el costo de la asignación es constante.

		El ciclo perteneciente a $secuencia\_unimodal$ ($for$), itera $n$ veces, siendo en el peor caso el costo de cada iteración acotado por una
		constante. La cantidad máxima de operaciones se da en las iteraciones que entra al caso condicional. El costo del $for$ es $n*c$ (con $c$ constante), es decir, \Ode{n}.

		Por lo tanto, el costo del algoritmo $secuencia\_unimodal$ es: \Ode{2*n + 2*n^2} que por definición es 
		\Ode{max(2*n, 2*n^2)} = \Ode{2*n^2} = \Ode{n^2}.
		
	\end{subsection}

	\newpage

	\begin{subsection}{Pruebas y Resultados}
		Para probar correctitud tenemos un generador de secuencias unimodales, secuencias crecientes y decrecientes que nos devuelve en un archivo $test\_*.in$, donde $*$ se refiere a $unimodal,\; creciente\; o\; decreciente$ según corresponda. De esta forma, con una comparación de archivos (comando \texttt{make diffs} en la carpeta Ej1) podemos saber para cada instancia si el resultado obtenido por nuestro algoritmo es correcto.

		Para llevar a cabo las pruebas de este algoritmo en cuanto a operaciones realizadas por instancia, generamos secuencias unimodales, crecientes, decrecientes y random con el objeto de constatar si los gráficos (a continuación expuestos), se condicen con la complejidad teórica analizada.\\

		En el siguiente gráfico, se ven sólo las instancias con $n$ múltiplo de $10$ para poder apreciar cada instancia para entrada unimodal, creciente, decreciente y random (si graficáramos todos los $n$ se vería una linea densa y no podríamos apreciar el comportamiento del algoritmo).

		\gra{secuencia_unimodal/count_test_unimodal.pdf}
		
		Podemos observar que para un $n$ dado, todos los casos vistos, coinciden en la cantidad de operaciones. Además la curva $n^2$ parece ser una buena cota para el algoritmo. Se aprecia también que a medida que $n$ crece, la diferencia entre $n^2$ y la cantidad de operaciones para nuestro algoritmo es cada vez mayor. Podemos decir entonces, que $n^2$ es una buena cota, pero que a medida que $n$ crece, el valor de la constante $c$ (coeficiente cuadrático) que fue despreciado, así como también su término lineal y el constante  (en el análisis de complejidad) contribuye a que la diferencia entre las dos curvas siga creciendo.\\

		El siguiente gráfico, muestra la cantidad de operaciones para $n$ entre $980$ y $1000$. Queremos ver si existe diferencia entre los distintos tipos de test, ya que en el gráfico anterior no pudimos ver estos resultados por la escala en la que trabajamos, y no podemos afirmar entonces que no existe tal diferencia.\\

		\gra{secuencia_unimodal/count_test_n_bajo.pdf}

		\newpage

		Corroboramos que a pesar de que es mínima, existe diferencia entre los distintos tipos de casos. Sabemos que la cantidad de operaciones para cada $n$ del gráfico es del orden de millones. La diferencia entre los diferentes tipos de secuencias para cada $n$ es de entre $1000$ y $10000$. A pesar de ser una gran diferencia de operaciones, en relación a la cantidad total, es {\em despreciable}.

	\end{subsection}

	\begin{subsection}{Concluciones}

		Como antes expusimos, para resolver el ejercicio, se utilizó la técnica de Programacion Dinámica, sin la cual no podríamos haber cumplido la complejidad impuesta, utilizando su gran ventaja de poder guardar los resultados anteriores en estructuras poco costosas.
		
		Luego de analizar el algoritmo de forma teórica y apreciar el comportamiento de este en diversas instancias en los gráficos, podemos concluir que el algoritmo encontrado para resolver el problema de la secuencia unimodal es adecuado, ya que pudimos mostrar que trabaja en complejidad polinomial, del orden de $n^2$, lo que significa que está 'bien' resuelto computacionalmente.
	\end{subsection}
\end{section}

