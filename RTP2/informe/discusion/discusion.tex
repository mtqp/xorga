\section{Discusión}
El código de este trabajo utiliza las funciones en lenguaje \code{C} del trabajo anterior 
y nuevas funciones en assembler. El trabajo en assembler está separado en un 
archivo por filtro a aplicar y un archivo para las \keyword{macros} en común, utilizadas 
por los filtros.
		
A continuación se detallara lo escrito y pensado para los diferentes algoritmos,
que fueron ajustados para mejor rendimiento según la matríz utilizada. Antes de 
empezar se definen nombres específicos (\keyword{macros}) para cada registro \code{xmm}, para facilitar la 
lectura del código. Los nombres definidos son: \code{srcl}, \code{srch} que contendrán las 
líneas leídas de la imagen original; \code{acul}, \code{acuh} que acumularán los resultados 
parciales del cálculo; y cuatro registros temporales \code{tmp1}, \code{tmp2}, \code{tmp3} y \code{tmp4} 
(en el caso del \keyword{Frei-Chen} el cuarto registro temporal se renombra a \code{sqrt2}).

Los algoritmos siguen una línea general, empiezan y terminan con lo definido en la convención C, 
se definen nombres de variables para los parámetros y se usan los registros generales de la siguiente manera:
\vspace{5mm}

\begin{tabular}{l p{10cm}}
	\code{eax}:&Almacena las variables \code{xOrder} e \code{yOrder} que indican sobre qué derivada realizar el procesamiento. \\
	\code{ebx}:&Contador para las filas. \\
	\code{ecx}:&Contador para las columnas. \\
	\code{edx}:&Ancho de la imagen. \\
	\code{esi}:&Puntero a la imagen fuente. \\
	\code{edi}:&Puntero a la imagen destino.
\end{tabular}

\vspace{5mm}
	Luego para cada fila de la imagen se realiza el procesamiento sobre la derivada de \code{x} o de \code{y} según sea necesario 
procesando de a 14 píxeles, y antes de terminar la fila se revisa si se pueden calcular exactamente 14 píxeles, sino se retroceden los 
punteros para poder lograrlo y se pasa a la siguiente fila.

\vspace{1cm}

\subsection{Estructura básica para \keyword{Sobel}, \keyword{Prewitt} y \keyword{Frei-Chen}}
	Los algoritmos de \keyword{Sobel}, \keyword{Prewitt} y \keyword{Frei-Chen} están estructurados de la misma manera. Cada uno tiene 
definidas sus propias \keyword{macros} denominadas \code{procesarLineaX}, \code{procesarLineaY}, \code{calcularX} y \code{calcularY}. 
De esta manera, el código de los tres filtros es bastante similar y para comprenderlos basta con entender la estructura básica de uno de 
ellos y luego los detalles particulares. La idea general del procesamiento se basa en las \keyword{macros} \code{procesarLineaX/Y}. Cada 
\keyword{macro} se encarga de leer 16 píxeles, hacer el procesamiento de los 14 píxeles procesables según la línea correspondiente de la 
matríz, y sumar el resultado de la operación en dos acumuladores. Las macros \code{calcularX} y \code{calcularY} son las encargadas de 
efectuar el procesamiento en paralelo de 6 píxeles convertidos a \keyword{word}. Cada algoritmo tiene sus versiones de ambas \keyword{macros}.
 Como estas \keyword{macros} no procesan todos los píxeles necesarios por limitaciones del método, cada algoritmo calcula individualmente 
los 2 píxeles centrales de los 16 levantados. Por último se empaquetan los datos y se guardan en la imagen resultante. 

\subsection{Sobel}

\subsubsection{Procesamiento en \code{x}}
	La \keyword{macro} \code{procesarLineaX} comienza cargando en los registros \code{srcl} y \code{srch} 16 píxeles de la imagen original, 
luego desempaqueta a ocho \keyword{words} adecuadamente con las instrucciones \code{punpcklbw} (\keyword{Unpack Low Bytes to Words}) y \code{punpckhbw} 
(\keyword{Unpack High Bytes to Words}). Mediante la \keyword{macro} \code{calcularX} se trabajan los ocho píxeles menos significativos contienidos en 
el registro \code{srcl}. Al aplicar convolución entre la primer línea de la matríz de \keyword{Sobel} ( 
\code{
\begin{tabular}{|c|c|c|}
	\hline
	-1 & 0 & 1 \\
	\hline
\end{tabular} 
}
) y una línea genérica 
\code{
\begin{tabular}{|c|c|c|}
	\hline
	a & b & c \\
	\hline
\end{tabular}
}
, el resultado esperado es 
\code{
\begin{tabular}{|c|c|c|}
	\hline
	c-a & d-b & e-c \\
	\hline
\end{tabular}
}
La \keyword{macro} \code{calcularX} obtiene el resultado esperado de 6 píxeles para \keyword{Sobel} en \code{x} de la siguiente manera:

\begin{center}
\code{
\begin{tabular}{r c l}
	src	&\reg{a}{b}{c}{d}{e}{f}{g}{h} &	\keyword{parámetro}	\\ \\
	tmp1	&\reg{a}{b}{c}{d}{e}{f}{g}{h} &	\keyword{copia src a tmp1}		\\ \\
	tmp1	&\reg{c}{d}{e}{f}{g}{h}{0}{0} & \keyword{shift 2 words $\leftarrow$}	\\ \\
	tmp1	&{\tiny\reg{c-a}{d-b}{e-c}{f-d}{g-e}{h-f}{-g}{-h}} & \keyword{resta src a tmp1} \\ \\
%	tmp1	&{\tiny\reg{000}{000}{c-a}{d-b}{e-c}{f-d}{g-e}{h-f}} & \keyword{shift 2 words $\rightarrow$} \\ \\
%	tmp1	&{\tiny\reg{000}{c-a}{d-b}{e-c}{f-d}{g-e}{h-f}{000}} & \keyword{shift 1 word $\leftarrow$} \\ \\
\end{tabular}
}
\end{center}

Luego de obtener el resultado mostrado en el esquema, se suman los 6 resultados válidos al acumulador correspondiente. 
Como la primer y tercer líneas son iguales y la segunda es el doble de la primera, se procesan todas las líneas con la misma \keyword{macro}. 
En el caso de estar procesando la segunda línea de la matríz (
\code{
\begin{tabular}{|c|c|c|}
	\hline
	-2 & 0 & 2 \\
	\hline
\end{tabular} 
}
), después de ejecutar la \keyword{macro} \code{calcularX}, se duplica el resultado obtenido.

	Los valores intermedios se acumulan en \code{acul} y \code{acuh} y, una vez calculados, se procesan los dos píxeles centrales de los 14 píxeles 
originales que debían ser procesados.

\subsubsection{Procesamiento en \code{y}}
	La idea detrás del procesamiento de Sobel en \code{y} es básicamente la misma al procesamiento en \code{x}. En este caso, al aplicar convolución 
entre la primer línea de la matríz (
\code{
\begin{tabular}{|c|c|c|}
	\hline
	-1 & -2 & -1 \\
	\hline
\end{tabular} 
}
) y una línea genérica (
\code{
\begin{tabular}{|c|c|c|}
	\hline
	a & b & c \\
	\hline
\end{tabular} 
}
), el resultado esperado es 
\code{
\begin{tabular}{|c|c|c|}
	\hline
	-a-2b-c & -b-2c-d & -c-2d-e \\
	\hline
\end{tabular}
}. Para obtener este resultado, se realiza el siguiente procedimiento:
\begin{center}
\code{
\begin{tabular}{r c l}
	src	&\reg{a}{b}{c}{d}{e}{f}{g}{h} &	\keyword{parámetro}	\\ \\
	tmp1	&\reg{a}{b}{c}{d}{e}{f}{g}{h} &	\keyword{copia src a tmp1}		\\ \\
	tmp1	&\reg{b}{c}{d}{e}{f}{g}{h}{0} &	\keyword{shift 1 word $\leftarrow$}	\\ \\
	tmp1	&\reg{2b}{2c}{2d}{2e}{2f}{2g}{2h}{0} &	\keyword{duplica tmp1}		\\ \\
	tmp1	&\tiny\reg{a+2b}{b+2c}{c+2d}{d+2e}{e+2f}{f+2g}{g+2h}{h} & \keyword{suma src a tmp1} \\ \\
	tmp2	&\reg{a}{b}{c}{d}{e}{f}{g}{h} &	\keyword{copia src a tmp2}		\\ \\
	tmp2	&\reg{c}{d}{e}{f}{g}{h}{0}{0} & \keyword{shift 2 words $\leftarrow$}	\\ \\
	tmp1	&\tiny\reg{a+2b+c}{b+2c+d}{c+2d+e}{d+2e+f}{e+2f+g}{f+2g+h}{g+2h}{h} & \keyword{suma tmp2 a tmp1} \\ \\
\end{tabular}
}
\end{center}

Luego de obtener el resultado mostrado en el esquema, se acumula el resultado de \code{calcularY} restando (en caso de estar calculando la primer 
línea de la matríz) o sumando (si se trata de la tercera). Esto se debe a que la matríz es igual en ambas líneas, salvo porque la primer línea es 
negativa. Como la matríz contiene sólo ceros en la segunda línea, no es necesario realizar los cálculos. 

\vspace{5mm}
\subsection{Prewitt}
\subsubsection{Procesamiento en \code{x}}
	El cálculo de \keyword{Prewitt} en \code{x} es idéntico al de la primer línea de \keyword{Sobel}. Basta con repetir 3 veces el mismo
procedimiento.

\subsubsection{Procesamiento en \code{y}}
	El cálculo de \keyword{Prewitt} en \code{y} es similar al de \keyword{Sobel}. El único cambio en el algoritmo es que no se efectúa el 3er
paso, es decir, no se duplica el registro temporal.

\vspace{5mm}
\subsection{Frei-Chen}
	Para poder calcular eficientemente el algoritmo, primero se calcula repetidamente $\sqrt{2}$ en un registro temporal (\code{sqrt2}).

\vspace{5mm}
\code{
\begin{tabular}{r c l}
	sqrt2	&\reg{$\sqrt{2}$}{$\sqrt{2}$}{$\sqrt{2}$}{$\sqrt{2}$}{$\sqrt{2}$}{$\sqrt{2}$}{$\sqrt{2}$}{$\sqrt{2}$}&	\keyword{raíces de 2}	\\ \\
\end{tabular}
}

\subsubsection{Procesamiento en \code{x}}
	El algoritmo realizado para \keyword{Frei-Chen} nuevamente es similar al de \keyword{Sobel}. En este caso, la diferencia reside únicamente
en la segunda línea, en la cuál se convierte el resultado intermedio a \keyword{float} para luego poder multiplicar por $\sqrt{2}$ (mediante el
registro \code{sqrt2} precalculado) y finalmente convertir el resultado a enteros y sumarlo al acumulador correspondiente.

\begin{center}[ FALTA EXPLICACION DE COMO SE HACE TODO ESO ]\end{center}
\subsubsection{Procesamiento en \code{y}}


\pagebreak

