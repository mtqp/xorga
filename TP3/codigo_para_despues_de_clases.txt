
                                   Algo de c'odigo del taller de interrupciones

-------------------------------------------------------------------------------
c'odigo para facilitar la generaci'on de la idt.
-------------------------------------------------------------------------------

#define IDT_ENTRY(numero) \
	idt[numero].offset_0_15 = (unsigned short) ((unsigned int)(&_isr ## numero) & (unsigned int) 0xFFFF); \
	idt[numero].segsel = (unsigned short) 0x0008; \
	idt[numero].attr = (unsigned short) 0x8E00; \
	idt[numero].offset_16_31 = (unsigned short) ((unsigned int)(&_isr ## numero) >> 16 & (unsigned int) 0xFFFF);

Para el ejemplo de la rutina n'umero 12 se instancia usando:

	IDT_ENTRY(12);

Esto genera:

	idt[12].offset_0_15 = (unsigned short) ((unsigned int)(&_isr12) & (unsigned int) 0xFFFF); \
	idt[12].segsel = (unsigned short) 0x0008; \
	idt[12].attr = (unsigned short) 0x8E00; \
	idt[12].offset_16_31 = (unsigned short) ((unsigned int)(&_isr12) >> 16 & (unsigned int) 0xFFFF);

Por lo tanto la etiqueta "_isr12" debe existir y corresponder a la funci'on que
atiende la interrupci'on del mismo numero.

-------------------------------------------------------------------------------
Rutinas para el reloj y el teclado
-------------------------------------------------------------------------------

global _isr32
_isr32:
		cli
		pushad
		inc DWORD [isrnumero]
		mov ebx, [isrnumero]
		cmp ebx, 0x5
		jl .ok
			mov DWORD [isrnumero], 0x0
			mov ebx, 0
		.ok:
			add ebx, isrmessage1
			mov edx, isrmessage

			IMPRIMIR_TEXTO edx, 6, 0x0A, 24, 0
			IMPRIMIR_TEXTO ebx, 1, 0x0A, 24, 7

		mov al, 0x20
		out 0x20, al

		popad
		sti
		iret

isrmessage: db 'Clock:'
isrnumero: dd 0x00000000
isrmessage1: db '('
isrmessage2: db '['
isrmessage3: db '-'
isrmessage4: db ']'
isrmessage5: db ')'

global _isr33
_isr33:
		cli
		pushad
		in al, 0x60

		test al, 0x80
		jnz .saltar

		mov ebx, letra_null
		inc ebx
		cmp al, [scan_a]
		jz .cont
		inc ebx
		cmp al, [scan_c]
		jz .cont
		inc ebx
		cmp al, [scan_r]
		jz .cont
		inc ebx
		cmp al, [scan_e]
		jz .cont
		mov ebx, letra_null
	.cont:
		mov ecx, [columna]
		IMPRIMIR_TEXTO ebx, 1, 0x0A, 23, ecx

		inc dword [columna]
	.saltar:
		mov al, 0x20
		out 0x20, al

		popad
		sti
		iret

columna: dd 0x0000000A
letra_null: db ' '
letra_a: db 'a'
letra_c: db 'c'
letra_r: db 'r'
letra_e: db 'e'
scan_a: db 0x1E
scan_c: db 0x2E
scan_r: db 0x13
scan_e: db 0x12